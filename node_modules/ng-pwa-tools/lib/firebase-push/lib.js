"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var lib_1 = require("../ls-routes/lib");
var ng_1 = require("../common/ng");
var util_1 = require("../common/util");
var cli_1 = require("./cli");
var p5 = require("parse5");
function isRouteFbCompatible() {
    return false;
}
var FbTerminalEvalState;
(function (FbTerminalEvalState) {
    FbTerminalEvalState[FbTerminalEvalState["PREFIX"] = 0] = "PREFIX";
    FbTerminalEvalState[FbTerminalEvalState["SUFFIX"] = 1] = "SUFFIX";
})(FbTerminalEvalState || (FbTerminalEvalState = {}));
function toFbCompatibleTerminal(_a, chunkMap) {
    var path = _a.path, loadChildren = _a.loadChildren, prefix = _a.prefix;
    var state = FbTerminalEvalState.PREFIX;
    var url = path
        .split('/')
        .reduce(function (url, segment) {
        if (url === null) {
            return null;
        }
        if (segment === '**' || segment.startsWith(':')) {
            if (state === FbTerminalEvalState.PREFIX) {
                url += url.endsWith('/') ? '*' : '/*';
            }
            state = FbTerminalEvalState.SUFFIX;
        }
        else {
            if (state === FbTerminalEvalState.SUFFIX) {
                return null;
            }
            url += '/' + segment;
        }
        return url;
    }, '');
    if (url === null) {
        return null;
    }
    if (state === FbTerminalEvalState.PREFIX && prefix) {
        url += url.endsWith('/') ? '*' : '/*';
    }
    if (url.endsWith('/') && url !== '/') {
        url = url.substr(0, url.length - 1);
    }
    var chunks = resolveLazyChunks(chunkMap, loadChildren);
    return { url: url, chunks: chunks };
}
function resolveLazyChunks(chunkMap, loadChildren) {
    return loadChildren
        .map(function (child) {
        var modulePath = child.split('#')[0];
        var factoryPath = modulePath + ".ngfactory";
        if (!chunkMap[factoryPath]) {
            throw new Error("No chunk found for module reference " + child);
        }
        return chunkMap[factoryPath];
    });
}
function getHeaderForLink(link) {
    return "<" + link.url + ">;rel=" + link.rel + ";as=" + link.as + (!!link.nopush ? ';nopush' : '');
}
function terminalToFbLinkWithSource(terminal, baseUrl) {
    var link = terminal
        .chunks
        .map(function (chunk) { return getLinkForFile(chunk, baseUrl); });
    return { source: terminal.url, link: link };
}
function getLinkForFile(file, baseUrl) {
    return {
        url: baseUrl + "/" + file,
        as: file.endsWith('.css') ? 'style' : 'script',
        rel: 'preload',
    };
}
function getStaticLinks(dist, baseUrl) {
    if (baseUrl === void 0) { baseUrl = '/'; }
    if (baseUrl.endsWith('/')) {
        baseUrl = baseUrl.substr(0, baseUrl.length - 1);
    }
    return util_1.recursiveListDir(dist)
        .filter(function (file) { return file.endsWith('.bundle.js') || file.endsWith('.css'); })
        .map(function (file) { return getLinkForFile(file, baseUrl); });
}
function getAttr(node, attr) {
    var matching = (node.attrs || [])
        .filter(function (entry) { return entry.name === attr; })
        .map(function (entry) { return entry.value; });
    if (matching.length === 0) {
        return null;
    }
    else if (matching.length > 1) {
        throw new Error('More than one attribute of given name!');
    }
    else {
        return matching[0];
    }
}
function getUrlFromNode(node) {
    if (!node.tagName) {
        return null;
    }
    switch (node.tagName) {
        case 'link': {
            var rel = getAttr(node, 'rel');
            if (!rel) {
                return null;
            }
            var url = getAttr(node, 'href');
            if (!url) {
                return null;
            }
            switch (rel) {
                case 'stylesheet':
                    return { url: url, as: 'style' };
                case 'preload':
                    var as = getAttr(node, 'as');
                    if (!as) {
                        return null;
                    }
                    return { url: url, as: as };
                default:
                    return null;
            }
        }
        case 'script': {
            var url = getAttr(node, 'src');
            if (!url) {
                return null;
            }
            return { url: url, as: 'script' };
        }
        case 'img': {
            var url = getAttr(node, 'src');
            if (!url) {
                return null;
            }
            return { url: url, as: 'image' };
        }
        default:
            return null;
    }
}
function getUrlsFromNodes(nodes) {
    return nodes
        .map(function (node) { return [getUrlFromNode(node)]
        .filter(function (url) { return url !== null; })
        .concat(node.childNodes ? getUrlsFromNodes(node.childNodes) : []); })
        .reduce(function (acc, urls) { return acc.concat(urls); }, []);
}
function getUrlsFromIndex(index) {
    var contents = fs.readFileSync(index).toString();
    var doc = p5.parse(contents, { locationInfo: false });
    return getUrlsFromNodes([doc]);
}
function isAbsolute(url) {
    var lc = url.toLowerCase();
    return lc.startsWith('/') || lc.startsWith('http://') || lc.startsWith('https://');
}
function getStaticLinksFromIndex(index, baseUrl) {
    if (baseUrl === void 0) { baseUrl = '/'; }
    if (baseUrl.endsWith('/')) {
        baseUrl = baseUrl.substr(0, baseUrl.length - 1);
    }
    var result = getUrlsFromIndex(index)
        .map(function (entry) { return ({
        url: isAbsolute(entry.url) ? entry.url : baseUrl + "/" + entry.url,
        rel: 'preload',
        as: entry.as
    }); });
    return Promise.resolve(result);
}
exports.getStaticLinksFromIndex = getStaticLinksFromIndex;
function getDynamicLinksFromApp(dist, appModule, loadChildrenRoot, baseUrl) {
    if (baseUrl === void 0) { baseUrl = '/'; }
    if (baseUrl.endsWith('/')) {
        baseUrl = baseUrl.substr(0, baseUrl.length - 1);
    }
    var chunks = cli_1.chunkMapForDist(dist);
    if (chunks === null) {
        throw new Error("Cannot read chunk map from " + dist + " - not a CLI project?");
    }
    var module = ng_1.loadNgModule(appModule);
    return lib_1.extractTerminals(module, loadChildrenRoot)
        .then(function (terminals) { return terminals
        .map(function (terminal) { return toFbCompatibleTerminal(terminal, chunks); })
        .filter(function (terminal) { return terminal !== null; })
        .map(function (terminal) { return terminalToFbLinkWithSource(terminal, baseUrl); })
        .reduce(function (acc, links) { return acc.concat(links); }, []); });
}
exports.getDynamicLinksFromApp = getDynamicLinksFromApp;
function getFbHostingConfig(sources, staticLinks) {
    return {
        headers: sources
            .map(function (source) {
            return {
                source: source.source,
                headers: [{
                        key: 'Link',
                        value: staticLinks
                            .concat(source.link)
                            .map(function (link) { return getHeaderForLink(link); })
                            .join(','),
                    }],
            };
        }),
    };
}
exports.getFbHostingConfig = getFbHostingConfig;
