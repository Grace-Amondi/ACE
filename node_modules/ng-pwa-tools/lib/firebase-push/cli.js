"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var ts = require("typescript");
var IS_CHUNK = /^[0-9]+\..*\.chunk\.js$/;
function name(node) {
    return ts.SyntaxKind[node.kind];
}
function printAst(node, space) {
    console.log(space, name(node));
    ts.forEachChild(node, function (child) {
        printAst(child, space + ' ');
    });
}
function interpretRouteMap(map, chunks, dist) {
    var routes = {};
    map.properties.forEach(function (property) {
        var propAssign = property;
        var key = propAssign.name.text;
        var value = propAssign.initializer;
        var index = value.elements[1];
        var chunkIndex = parseInt(index.text);
        routes[key] = findChunk(chunks, chunkIndex, dist);
    });
    return routes;
}
function keyIsModuleFactory(property) {
    if (property.kind !== ts.SyntaxKind.PropertyAssignment) {
        return false;
    }
    var propExpr = property;
    if (propExpr.name.kind !== ts.SyntaxKind.StringLiteral) {
        return false;
    }
    if (propExpr.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {
        return false;
    }
    var value = propExpr.initializer;
    if (value.elements.length !== 2) {
        return false;
    }
    if (value.elements[0].kind !== ts.SyntaxKind.StringLiteral) {
        return false;
    }
    if (value.elements[1].kind !== ts.SyntaxKind.FirstLiteralToken) {
        return false;
    }
    var name = propExpr.name;
    return name.text.endsWith('.ngfactory');
}
function keysAreModuleFactories(node) {
    return node
        .properties
        .every(function (property) { return keyIsModuleFactory(property); });
}
function varStmtToValue(varStmt) {
    if (varStmt.declarationList.declarations.length !== 1) {
        return null;
    }
    return varStmt.declarationList.declarations[0].initializer;
}
function maybeGetRouteMapForModule(module) {
    var exprs = module
        .statements
        .filter(function (stmt) { return stmt.kind === ts.SyntaxKind.VariableStatement; })
        .map(function (stmt) { return varStmtToValue(stmt); })
        .filter(function (node) { return node != null && node.kind === ts.SyntaxKind.ObjectLiteralExpression; })
        .map(function (stmt) { return stmt; })
        .filter(function (stmt) { return keysAreModuleFactories(stmt); });
    if (exprs.length === 0) {
        return null;
    }
    else if (exprs.length > 1) {
        throw new Error('Multiple route maps found');
    }
    else {
        return exprs[0];
    }
}
function routeMapFromSource(source) {
    if (source.statements.length < 1) {
        throw new Error('No statements in bundle.');
    }
    if (source.statements[0].kind !== ts.SyntaxKind.ExpressionStatement) {
        throw new Error('Top-level statement is not expression.');
    }
    var webpackExpr = source.statements[0];
    if (webpackExpr.expression.kind !== ts.SyntaxKind.CallExpression) {
        throw new Error('Top-level statement is not a call expression.');
    }
    var webpackCall = webpackExpr.expression;
    if (webpackCall.arguments.length !== 3) {
        throw new Error('Webpack call does not have expected number of arguments.');
    }
    if (webpackCall.arguments[1].kind !== ts.SyntaxKind.ObjectLiteralExpression) {
        throw new Error('Webpack call does not have a module map as 2nd argument.');
    }
    var moduleMap = webpackCall.arguments[1];
    var modules = [];
    moduleMap.properties.forEach(function (child) {
        if (child.kind !== ts.SyntaxKind.PropertyAssignment) {
            throw new Error('Module map has non-property-assignment entry.');
        }
        var assignment = child;
        if (assignment.initializer.kind !== ts.SyntaxKind.FunctionExpression) {
            throw new Error('Module entry is not a function.');
        }
        var moduleFn = assignment.initializer;
        modules.push(moduleFn.body);
    });
    var routeMaps = modules
        .map(function (module) { return maybeGetRouteMapForModule(module); })
        .filter(function (routeMap) { return routeMap !== null; });
    if (routeMaps.length === 0) {
        return null;
    }
    else if (routeMaps.length > 1) {
        throw new Error('More than one route map found.');
    }
    else {
        return routeMaps[0];
    }
}
function findChunk(chunks, index, dist) {
    var prefix = index + ".";
    var matches = chunks.filter(function (chunk) { return chunk.startsWith(prefix); });
    if (matches.length === 0) {
        throw new Error("No " + prefix + "*.js found in " + dist);
    }
    else if (matches.length > 1) {
        throw new Error("Too many " + prefix + "*.js files found in " + dist);
    }
    return matches[0];
}
function chunkMapForDist(dist) {
    var files = fs
        .readdirSync(dist)
        .filter(function (file) { return fs.statSync(path.join(dist, file)).isFile(); });
    var mains = files.filter(function (file) { return file.startsWith('main.') && file.endsWith('.js'); });
    var chunks = files.filter(function (file) { return IS_CHUNK.test(file); });
    if (mains.length === 0) {
        throw new Error("No main.*.js found in " + dist);
    }
    else if (mains.length > 1) {
        throw new Error("Too many main.*.js files found in " + dist);
    }
    var sourceText = fs.readFileSync(path.join(dist, mains[0])).toString();
    var source = ts.createSourceFile(process.argv[2], sourceText, ts.ScriptTarget.ES5, false, ts.ScriptKind.JS);
    var map = routeMapFromSource(source);
    if (map === null) {
        return null;
    }
    return interpretRouteMap(map, chunks, dist);
}
exports.chunkMapForDist = chunkMapForDist;
