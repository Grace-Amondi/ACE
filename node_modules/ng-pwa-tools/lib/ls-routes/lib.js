"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var core_1 = require("@angular/core");
var router_1 = require("@angular/router");
var platform_server_1 = require("@angular/platform-server");
var ng_1 = require("../common/ng");
function resolveLoadChildren(loadChildren, loadChildrenRoot) {
    if (typeof loadChildren === 'function') {
        return loadChildren();
    }
    else {
        var _a = loadChildren.split('#'), moduleFile = _a[0], moduleName = _a[1];
        return ng_1.loadNgModule(path.join(loadChildrenRoot, moduleFile), moduleName);
    }
}
function expandLazyChildrenOfRoute(route, injector, loadChildrenRoot) {
    if (!route.loadChildren) {
        return Promise.resolve(route);
    }
    var module = resolveLoadChildren(route['loadChildren'], loadChildrenRoot);
    return readRoutesForModule(module, injector)
        .then(function (childRoutes) {
        route.children = childRoutes;
        return route;
    });
}
function expandLazyChildren(routes, injector, loadChildrenRoot) {
    return Promise.all(routes
        .map(function (route) { return expandLazyChildrenOfRoute(route, injector, loadChildrenRoot); }));
}
function flattenRoutes(routes) {
    return routes.reduce(function (acc, routes) { return acc.concat(routes); }, []);
}
function readRoutesForModule(module, injector, loadChildrenRoot) {
    return ng_1.jitCompiler()
        .compileModuleAsync(module)
        .then(function (factory) { return factory.create(injector); })
        .then(function (ref) {
        var routes = flattenRoutes(ref.injector.get(router_1.ROUTES));
        if (loadChildrenRoot) {
            return expandLazyChildren(routes, ref.injector, loadChildrenRoot);
        }
        else {
            return routes;
        }
    });
}
function extractRoutes(module, loadChildrenRoot) {
    var FakeServerModule = (function () {
        function FakeServerModule() {
        }
        return FakeServerModule;
    }());
    FakeServerModule = __decorate([
        core_1.NgModule({
            imports: [
                module,
                platform_server_1.ServerModule,
            ],
        })
    ], FakeServerModule);
    var ngZone = new core_1.NgZone({ enableLongStackTrace: false });
    var injector = core_1.ReflectiveInjector.resolveAndCreate([{ provide: core_1.NgZone, useValue: ngZone }], platform_server_1.platformServer().injector);
    return readRoutesForModule(FakeServerModule, injector, loadChildrenRoot);
}
exports.extractRoutes = extractRoutes;
function extractTerminals(module, loadChildrenRoot) {
    return extractRoutes(module, loadChildrenRoot)
        .then(function (routes) { return coalesceToTerminals(routes); });
}
exports.extractTerminals = extractTerminals;
function coalesceRouteToTerminals(route, prefixSegments, loadChildren) {
    if (!route.children || route.children.length === 0) {
        // Route is a terminal.
        return [{
                path: prefixSegments
                    .filter(function (seg) { return seg !== ''; })
                    .concat([route.path])
                    .join('/'),
                prefix: route.pathMatch === 'prefix',
                loadChildren: loadChildren,
            }];
    }
    else {
        // Route is non-terminal.
        var newSegments_1 = prefixSegments.concat([route.path]);
        var loadChildrenDir = (typeof route.loadChildren === 'string') ? route.loadChildren : null;
        var newLoadChildren_1 = loadChildrenDir !== null ? loadChildren.concat([loadChildrenDir]) : loadChildren;
        return route
            .children
            .map(function (child) { return coalesceRouteToTerminals(child, newSegments_1, newLoadChildren_1); })
            .reduce(function (acc, terminals) { return acc.concat(terminals); }, []);
    }
}
function coalesceToTerminals(routes) {
    return routes
        .map(function (route) { return coalesceRouteToTerminals(route, [], []); })
        .reduce(function (acc, terminals) { return acc.concat(terminals); }, []);
}
exports.coalesceToTerminals = coalesceToTerminals;
function regexForSegment(segment) {
    if (segment.startsWith(':')) {
        return { segment: '[^/]+', pure: false };
    }
    else if (segment === '**') {
        return { segment: '.*', pure: false };
    }
    else {
        return { segment: segment, pure: true };
    }
}
function matcherForTerminal(route, baseUrl) {
    if (baseUrl === void 0) { baseUrl = '/'; }
    if (baseUrl.endsWith('/')) {
        baseUrl = baseUrl.substr(0, baseUrl.length - 1);
    }
    var body = route
        .path
        .split('/')
        .map(function (segment) { return regexForSegment(segment); });
    var pattern = baseUrl + '/' + body.map(function (segment) { return segment.segment; }).join('/');
    if (body.every(function (segment) { return segment.pure; })) {
        if (pattern.endsWith('/') && pattern !== '/') {
            pattern = pattern.substr(0, pattern.length - 1);
        }
        if (route.prefix) {
            return { pattern: pattern, match: 'prefix' };
        }
        else {
            return { pattern: pattern, match: 'exact' };
        }
    }
    else {
        var suffix = route.prefix ? '(/.*)?' : '';
        return { pattern: "^" + pattern + suffix + "$", match: 'regex' };
    }
}
exports.matcherForTerminal = matcherForTerminal;
