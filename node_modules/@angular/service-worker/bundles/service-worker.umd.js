(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/BehaviorSubject'), require('rxjs/Observable'), require('base64-js'), require('rxjs/add/observable/concat'), require('rxjs/add/observable/defer'), require('rxjs/add/observable/empty'), require('rxjs/add/observable/from'), require('rxjs/add/observable/fromEvent'), require('rxjs/add/observable/merge'), require('rxjs/add/observable/of'), require('rxjs/add/observable/timer'), require('rxjs/add/operator/concatMap'), require('rxjs/add/operator/do'), require('rxjs/add/operator/expand'), require('rxjs/add/operator/filter'), require('rxjs/add/operator/first'), require('rxjs/add/operator/let'), require('rxjs/add/operator/map'), require('rxjs/add/operator/mergeMap'), require('rxjs/add/operator/publishReplay'), require('rxjs/add/operator/reduce'), require('rxjs/add/operator/share'), require('rxjs/add/operator/switchMap'), require('rxjs/add/operator/take'), require('rxjs/add/operator/takeWhile')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/BehaviorSubject', 'rxjs/Observable', 'base64-js', 'rxjs/add/observable/concat', 'rxjs/add/observable/defer', 'rxjs/add/observable/empty', 'rxjs/add/observable/from', 'rxjs/add/observable/fromEvent', 'rxjs/add/observable/merge', 'rxjs/add/observable/of', 'rxjs/add/observable/timer', 'rxjs/add/operator/concatMap', 'rxjs/add/operator/do', 'rxjs/add/operator/expand', 'rxjs/add/operator/filter', 'rxjs/add/operator/first', 'rxjs/add/operator/let', 'rxjs/add/operator/map', 'rxjs/add/operator/mergeMap', 'rxjs/add/operator/publishReplay', 'rxjs/add/operator/reduce', 'rxjs/add/operator/share', 'rxjs/add/operator/switchMap', 'rxjs/add/operator/take', 'rxjs/add/operator/takeWhile'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.serviceWorker = global.ng.serviceWorker || {}),global.ng.core,global.Rx,global.Rx,global.Base64Js,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx,global.Rx));
}(this, (function (exports,_angular_core,rxjs_BehaviorSubject,rxjs_Observable,base64Js,rxjs_add_observable_concat,rxjs_add_observable_defer,rxjs_add_observable_empty,rxjs_add_observable_from,rxjs_add_observable_fromEvent,rxjs_add_observable_merge,rxjs_add_observable_of,rxjs_add_observable_timer,rxjs_add_operator_concatMap,rxjs_add_operator_do,rxjs_add_operator_expand,rxjs_add_operator_filter,rxjs_add_operator_first,rxjs_add_operator_let,rxjs_add_operator_map,rxjs_add_operator_mergeMap,rxjs_add_operator_publishReplay,rxjs_add_operator_reduce,rxjs_add_operator_share,rxjs_add_operator_switchMap,rxjs_add_operator_take,rxjs_add_operator_takeWhile) { 'use strict';

function fromPromise(promiseFn) {
    return rxjs_Observable.Observable.create(function (observer) {
        promiseFn()
            .then(function (v) { return observer.next(v); })
            .then(function () { return observer.complete(); })
            .catch(function (err) { return observer.error(err); });
    });
}
// A push notification registration, including the endpoint URL and encryption keys.
var NgPushRegistration = (function () {
    function NgPushRegistration(ps) {
        this.ps = ps;
    }
    // Get the authentication key
    NgPushRegistration.prototype.auth = function () {
        return this.key('auth');
    };
    NgPushRegistration.prototype.key = function (method) {
        if (method === void 0) { method = 'p256dh'; }
        return base64Js.fromByteArray(new Uint8Array(this.ps.getKey(method)));
    };
    Object.defineProperty(NgPushRegistration.prototype, "url", {
        get: function () {
            return this.ps.endpoint;
        },
        enumerable: true,
        configurable: true
    });
    NgPushRegistration.prototype.toJSON = function () {
        return this.ps.toJSON();
    };
    NgPushRegistration.prototype.unsubscribe = function () {
        var _this = this;
        // TODO: switch to Observable.fromPromise when it's not broken.
        return fromPromise(function () { return _this.ps.unsubscribe(); });
    };
    return NgPushRegistration;
}());
var NgServiceWorker = (function () {
    function NgServiceWorker(zone) {
        var _this = this;
        this.zone = zone;
        // Always returns the current controlling worker, or undefined if there isn't one.
        this.controllingWorker = new rxjs_BehaviorSubject.BehaviorSubject(undefined);
        // Extract a typed version of navigator.serviceWorker.
        this.container = (typeof navigator === 'object') && navigator['serviceWorker'];
        if (!!this.container) {
            // Final Observable that will always give back the current controlling worker,
            // and follow changes over time.
            rxjs_Observable.Observable
                .concat(
            // Current controlling worker (if any).
            rxjs_Observable.Observable.of(this.container.controller), 
            // Future changes of the controlling worker.
            rxjs_Observable.Observable
                .fromEvent(this.container, 'controllerchange')
                .map(function (_) { return _this.container.controller; }))
                .subscribe(function (worker) { return _this.controllingWorker.next(worker); }, function (err) { return _this.controllingWorker.error(err); }, function () { return _this.controllingWorker.complete(); });
        }
        // To make one-off calls to the worker, awaitSingleControllingWorker waits for
        // a controlling worker to exist.
        this.awaitSingleControllingWorker = this
            .controllingWorker
            .filter(function (worker) { return !!worker; })
            .take(1);
        // Setup the push Observable as a broadcast mechanism for push notifications.
        this.push = rxjs_Observable.Observable
            .defer(function () { return _this.send({ cmd: 'push' }); })
            .share();
        // Setup the updates Observable as a broadcast mechanism for update notifications.
        this.updates = rxjs_Observable.Observable
            .defer(function () { return _this.send({ cmd: 'update' }); })
            .share();
    }
    NgServiceWorker.prototype.registrationForWorker = function () {
        var _this = this;
        return function (obs) { return obs
            .switchMap(function (worker) { return fromPromise(function () { return _this.container.getRegistrations(); })
            .expand(function (regs) { return rxjs_Observable.Observable.from(regs); })
            .filter(function (reg) { return reg.active === worker; })
            .take(1); }); };
    };
    // Sends a single message to the worker, and awaits one (or more) responses.
    NgServiceWorker.prototype.sendToWorker = function (worker, message) {
        var _this = this;
        // A MessageChannel is sent with the message so responses can be correlated.
        var channel = new MessageChannel();
        // Observe replies.
        var result = new rxjs_Observable.Observable(function (observer) {
            var cancelId = null;
            var listener = function (event) {
                var data = event.data;
                if (!!data && typeof data === "object" && data.hasOwnProperty('$ngsw') && data.hasOwnProperty('id')) {
                    cancelId = data['id'];
                }
                else if (data === null) {
                    observer.complete();
                    channel.port1.removeEventListener('message', listener);
                    return;
                }
                else {
                    observer.next(data);
                }
            };
            channel.port1.addEventListener('message', listener);
            return function () {
                channel.port1.removeEventListener('message', listener);
                _this.sendToWorker(worker, { cmd: 'cancel', id: cancelId });
            };
        })
            .takeWhile(function (v) { return !!v; })
            .publishReplay();
        // Connecting actually creates the event subscription and starts recording
        // for replay.
        result.connect();
        // Start receiving message(s).
        channel.port1.start();
        // Set a magic value in the message.
        message['$ngsw'] = true;
        worker.postMessage(message, [channel.port2]);
        return result;
    };
    // Send a message to the current controlling worker, waiting for one if needed.
    NgServiceWorker.prototype.send = function (message) {
        var _this = this;
        return this
            .awaitSingleControllingWorker
            .switchMap(function (worker) { return _this.sendToWorker(worker, message); });
    };
    // Send a 'ping' to the worker. The returned Observable will complete when the worker
    // acknowledges the message. This provides a test that the worker is alive and listening.
    NgServiceWorker.prototype.ping = function () {
        return this.send({
            cmd: 'ping'
        });
    };
    NgServiceWorker.prototype.log = function () {
        return this.send({
            cmd: 'log'
        });
    };
    NgServiceWorker.prototype.activateUpdate = function (version) {
        return this.send({
            cmd: 'activateUpdate',
            version: version,
        });
    };
    NgServiceWorker.prototype.registerForPush = function (pushOptions) {
        var _this = this;
        if (pushOptions === void 0) { pushOptions = {}; }
        return this
            .awaitSingleControllingWorker
            .let(this.registrationForWorker())
            .map(function (worker) { return worker.pushManager; })
            .switchMap(function (pushManager) {
            // Create an Observable to wrap the Promises of the PushManager API.
            // TODO: switch to Observable.fromPromise when it's not broken.
            // This is extracted as a variable so Typescript infers types correctly.
            var reg = rxjs_Observable.Observable.create(function (observer) {
                // Function that maps subscriptions to an Angular-specific representation.
                var regFromSub = function (sub) { return new NgPushRegistration(sub); };
                pushManager
                    .getSubscription()
                    .then(function (sub) {
                    // If there is one, we don't need to register, just return it.
                    if (!!sub) {
                        return regFromSub(sub);
                    }
                    // No existing subscription, register (with userVisibleOnly: true).
                    var options = {
                        userVisibleOnly: true,
                    };
                    if (pushOptions.applicationServerKey) {
                        var key = atob(pushOptions
                            .applicationServerKey
                            .replace(/_/g, '/')
                            .replace(/-/g, '+'));
                        var applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));
                        for (var i = 0; i < key.length; i++) {
                            applicationServerKey[i] = key.charCodeAt(i);
                        }
                        options['applicationServerKey'] = applicationServerKey;
                    }
                    return pushManager
                        .subscribe(options)
                        .then(regFromSub);
                })
                    .then(function (sub) { return _this.zone.run(function () { return observer.next(sub); }); })
                    .then(function () { return _this.zone.run(function () { return observer.complete(); }); })
                    .catch(function (err) { return _this.zone.run(function () { return observer.error(err); }); });
            });
            return reg;
        });
    };
    NgServiceWorker.prototype.checkForUpdate = function () {
        return this.send({ cmd: 'checkUpdate' });
    };
    return NgServiceWorker;
}());
NgServiceWorker.decorators = [
    { type: _angular_core.Injectable },
];
/** @nocollapse */
NgServiceWorker.ctorParameters = function () { return [
    { type: _angular_core.NgZone, },
]; };

var ServiceWorkerModule = (function () {
    function ServiceWorkerModule() {
    }
    return ServiceWorkerModule;
}());
ServiceWorkerModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                providers: [NgServiceWorker],
            },] },
];
/** @nocollapse */
ServiceWorkerModule.ctorParameters = function () { return []; };

exports.NgServiceWorker = NgServiceWorker;
exports.NgPushRegistration = NgPushRegistration;
exports.ServiceWorkerModule = ServiceWorkerModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));