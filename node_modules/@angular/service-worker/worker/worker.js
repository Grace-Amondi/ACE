import { fetchFromNetworkInstruction } from './common';
var VersionWorkerImpl = (function () {
    function VersionWorkerImpl(streamController, scope, manifest, adapter, cache, clock, fetcher, plugins) {
        this.streamController = streamController;
        this.scope = scope;
        this.manifest = manifest;
        this.adapter = adapter;
        this.cache = cache;
        this.clock = clock;
        this.fetcher = fetcher;
        this.plugins = plugins;
    }
    VersionWorkerImpl.prototype.refresh = function (req, cacheBust) {
        if (cacheBust === void 0) { cacheBust = true; }
        if (cacheBust) {
            return this.fetcher.refresh(req);
        }
        else {
            return this.fetcher.request(req);
        }
    };
    VersionWorkerImpl.prototype.fetch = function (req) {
        var _this = this;
        var fromNetwork = fetchFromNetworkInstruction(this, req, false);
        return this
            .plugins
            .filter(function (plugin) { return !!plugin.fetch; })
            .map(function (plugin) { return plugin.fetch(req); })
            .filter(function (instruction) { return !!instruction; })
            .reduceRight(function (delegate, curr) { return function () { return curr(delegate); }; }, function () { return _this.fetcher.request(req, true); })();
    };
    VersionWorkerImpl.prototype.validate = function () {
        return Promise
            .all(this
            .plugins
            .filter(function (plugin) { return !!plugin.validate; })
            .map(function (plugin) { return plugin.validate(); }))
            .then(function (results) { return results.every(function (v) { return v; }); });
    };
    VersionWorkerImpl.prototype.setup = function (previous) {
        var operations = [];
        for (var i = 0; i < this.plugins.length; i++) {
            var plugin = this.plugins[i];
            if (plugin.update && previous) {
                plugin.update(operations, previous.plugins[i]);
            }
            else {
                plugin.setup(operations);
            }
        }
        return operations.reduce(function (prev, curr) { return prev.then(function () { return curr(); }); }, Promise.resolve(null));
    };
    VersionWorkerImpl.prototype.cleanup = function () {
        return this.plugins.reduce(function (ops, plugin) {
            if (plugin.cleanup) {
                plugin.cleanup(ops);
            }
            return ops;
        }, []);
    };
    VersionWorkerImpl.prototype.message = function (message, id) {
        this
            .plugins
            .filter(function (plugin) { return !!plugin.message; })
            .forEach(function (plugin) { return plugin.message(message, id); });
    };
    VersionWorkerImpl.prototype.messageClosed = function (id) {
        this
            .plugins
            .filter(function (plugin) { return !!plugin.messageClosed; })
            .forEach(function (plugin) { return plugin.messageClosed(id); });
    };
    VersionWorkerImpl.prototype.sendToStream = function (id, message) {
        this.streamController.sendToStream(id, message);
    };
    VersionWorkerImpl.prototype.closeStream = function (id) {
        this.streamController.closeStream(id);
    };
    VersionWorkerImpl.prototype.push = function (data) {
        this
            .plugins
            .filter(function (plugin) { return !!plugin.push; })
            .forEach(function (plugin) { return plugin.push(data); });
    };
    VersionWorkerImpl.prototype.showNotification = function (title, options) {
        this.scope.registration.showNotification(title, options);
    };
    return VersionWorkerImpl;
}());
export { VersionWorkerImpl };
//# sourceMappingURL=worker.js.map