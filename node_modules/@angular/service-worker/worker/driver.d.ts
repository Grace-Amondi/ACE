import { PluginFactory } from './api';
import { NgSwAdapter, NgSwCache, NgSwEvents, NgSwFetch, Clock } from './facade';
/**
 * Possible states for the service worker.
 */
export declare enum DriverState {
    STARTUP = 0,
    READY = 1,
    UPDATE_PENDING = 2,
    INSTALLING = 3,
    LAME = 4,
}
/**
 * Manages the lifecycle of the Angular service worker.
 *
 * `Driver` is a singleton within the worker. It attempts to instantiate a `VersionWorker`,
 * a class that serves fetch (and other) events according to the instructions defined in a
 * particular version of a manifest file. The `Driver` maintains an active `VersionWorker`
 * and routes events to it when possible. A state machine ensures the `Driver` always
 * responds to traffic correctly.
 *
 * A principle consideration for choosing a 'correct' manifest with which to serve traffic
 * is when to switch to a new (updated) version of the manifest. `Driver` is responsible
 * for periodically downloading fresh versions of the manifest from the server, staging
 * a new `VersionWorker` if the manifest has been updated, and deciding when to switch app
 * traffic from the old to the new manifest. A large part of `Driver`'s logic is devoted
 * to this update process.
 *
 * At a high level, updates follow this process:
 *
 * 1) When a new `Driver` is created (worker startup), it initializes into a READY state
 *    and then checks for an updated manifest from the network.
 *
 * 2) If such a manifest is found, the `Driver` creates a new `VersionWorker` and attempts
 *    to set it up successfully, updating files from the old `VersionWorker` currently
 *    serving traffic.
 *
 * 3) If that update is successful, the driver queues the new manifest as staged and
 *    enters an UPDATE_PENDING state.
 *
 * 4) On the next `fetch` event that meets all the criteria for an update, the `Driver`
 *    activates the stage manifest, begins serving traffic with the new `VersionWorker`,
 *    and instructs the old `VersionWorker to clear up.
 */
export declare class Driver {
    private manifestUrl;
    private plugins;
    private scope;
    private adapter;
    private cache;
    private events;
    fetcher: NgSwFetch;
    clock: Clock;
    private state;
    private pendingUpdateHash;
    private id;
    private init;
    private active;
    private scopedCache;
    private streamId;
    private streams;
    private lifecycleLog;
    ready: Promise<any>;
    readyResolve: Function;
    updatePending: Promise<any>;
    updatePendingResolve: Function;
    private updateListeners;
    constructor(manifestUrl: string, plugins: PluginFactory<any>[], scope: ServiceWorkerGlobalScope, adapter: NgSwAdapter, cache: NgSwCache, events: NgSwEvents, fetcher: NgSwFetch, clock: Clock);
    /**
     * Write a message to the lifecycle log.
     */
    private lifecycle(msg);
    /**
     * Attempt to reset the service worker to a pristine state, as if one had never been installed
     * before.
     *
     * This involves removing all of the caches that fall under the `ScopedCache` used by the
     * worker.
     */
    private reset();
    /**
     * Start up the worker.
     *
     * this.init is set up as a Promise that resolves when the worker exits the STARTUP state.
     * In the background, it also kicks off a check for a new version of the manifest.
     *
     * In the usual update flow, this means that the worker will first transition to READY,
     * and then to UPDATE_PENDING when the updated manifest is set up and ready to be served.
     */
    private startup();
    /**
     * Possibly switch to a pending manifest if it's safe to do so.
     *
     * Safety is determined by whether there are other application tabs open, since they may
     * be depending on the worker to serve lazily-loaded js from the previous version of the
     * app, or it may be using a shared IndexedDB across all the tabs that can't be updated
     * yet, etc.
     */
    private maybeUpdate(clientId);
    /**
     * Switch to the staged worker (if any).
     *
     * After updating, the worker will be in state READY, always. If a staged manifest
     * was present and validated, it will be set as active.
     *
     * If `expectVersion` is set but the staged manifest does not match the expected
     * version, the update is skipped and the result resolves to false.
     */
    private doUpdate(expectVersion?);
    /**
     * Clear the currently active manifest (if any).
     */
    private clearActive();
    /**
     * Clear the currently staged manifest (if any).
     */
    private clearStaged();
    /**
     * Check the network for a new version of the manifest, and stage it if possible.
     *
     * This will request a new copy of the manifest from the network and compare it with
     * both the active manifest and any staged manifest if present.
     *
     * If the manifest is newer than the active or the staged manifest, it will be loaded
     * and the setup process run for all installed plugins. If it passes that process, it
     * will be set as the staged manifest, and the worker state will be set to UPDATE_PENDING.
     *
     * checkForUpdate() returns a boolean indicating whether a staged update is pending,
     * regardless of whether this particular call caused the update to become staged.
     */
    private checkForUpdate();
    /**
     * Transitions the worker out of the STARTUP state, by either serving the active
     * manifest or installing from the network if one is not present.
     *
     * Initialization can fail, which will result in the worker ending up in a LAME
     * state where it effectively disables itself until the next startup.
     *
     * This function returns a Promise which, when resolved, guarantees the worker is
     * no longer in a STARTUP state.
     */
    private initialize();
    /**
     * Fetch and install a manifest from the network.
     *
     * If successful, the manifest will become active and the worker will finish in state
     * READY. If any errors are encountered, the worker will transition to a LAME state.
     */
    private doInstallFromNetwork();
    /**
     * Fetch a cached copy of the manifest.
     */
    private fetchManifestFromCache(cache);
    /**
     * Fetch a copy of the manifest from the network.
     *
     * Resolves with null on a failure.
     */
    private fetchManifestFromNetwork();
    /**
     * Parse the given `Response` and return a `Manifest` object.
     */
    private manifestFromResponse(resp);
    /**
     * Store the given `Manifest` in the given cache.
     */
    private setManifest(manifest, cache);
    /**
     * Construct a `VersionWorker` for the given manifest.
     *
     * This worker will have all of the plugins specified during the bootstrap process installed,
     * but not yet initialized (setup()).
     */
    private workerFromManifest(manifest);
    /**
     * Instantiates a `VersionWorker` from a manifest and runs it through its setup process.
     *
     * Optionally, the worker can be directed to update from an existing `VersionWorker`
     * instead of performing a fresh setup. This can save time if resources have not changed
     * between the old and new manifests.
     */
    private setupManifest(manifest, existing?);
    /**
     * Instantiates a `VersionWorker` from a manifest that was previously set up according
     * by `setupManifest`.
     *
     * The worker will be validated (its caches checked against the manifest to assure all
     * resources listed are cached properly). If it passes validation, the returned Promise
     * will resolve with the worker instance, if not it resolves with `null`.
     */
    private openManifest(manifest);
    /**
     * Run a `VersionWorker` through its cleanup process, resolving when it completes.
     */
    private cleanup(worker);
    /**
     * Fetch the status of the `Driver`, including current state and lifecycle messages.
     */
    private status();
    /**
     * Transition into a new state.
     *
     * `transition` logs the transition, and also handles resolving several promises useful
     * for testing the more asynchronous parts of the `Driver` which aren't exposed via the
     * more public API.
     */
    private transition(state);
    /**
     * Process a `postMessage` received by the worker.
     */
    private handleMessage(message, id);
    /**
     * Remove the given stream id from the set of subscribers to update events, if present.
     */
    private maybeRemoveUpdateListener(id);
    /**
     * Post a message to the stream with the given id.
     */
    sendToStream(id: number, message: Object): void;
    /**
     * Complete the stream with the given id.
     *
     * Per the protocol between the service worker and client tabs, a completion is modeled as
     * a null message.
     */
    closeStream(id: number): void;
}
