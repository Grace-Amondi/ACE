import { VersionWorkerImpl } from './worker';
import { ScopedCache } from './cache';
import { LOGGER } from './logging';
import { parseManifest } from './manifest';
var driverId = 0;
/**
 * Possible states for the service worker.
 */
export var DriverState;
(function (DriverState) {
    // Just starting up - this is the initial state. The worker is not servicing requests yet.
    // Crucially, it does not know if it is an active worker, or is being freshly installed or
    // updated.
    DriverState[DriverState["STARTUP"] = 0] = "STARTUP";
    // The service worker has an active manifest and is currently serving traffic.
    DriverState[DriverState["READY"] = 1] = "READY";
    // The service worker is READY, but also has an updated manifest staged. When a fetch
    // is received and no current tabs are open, the worker may choose to activate the
    // pending manifest and discard the old one, in which case it will transition to READY.
    DriverState[DriverState["UPDATE_PENDING"] = 2] = "UPDATE_PENDING";
    // The worker has started up, but had no active manifest cached. In this case, it must
    // download from the network.
    DriverState[DriverState["INSTALLING"] = 3] = "INSTALLING";
    // Something happened that prevented the worker from reaching a good state. In the LAME
    // state the worker forwards all requests directly to the network, effectively self-disabling.
    // The worker will not recover from this state until it is terminated.
    DriverState[DriverState["LAME"] = 4] = "LAME";
})(DriverState || (DriverState = {}));
/**
 * Manages the lifecycle of the Angular service worker.
 *
 * `Driver` is a singleton within the worker. It attempts to instantiate a `VersionWorker`,
 * a class that serves fetch (and other) events according to the instructions defined in a
 * particular version of a manifest file. The `Driver` maintains an active `VersionWorker`
 * and routes events to it when possible. A state machine ensures the `Driver` always
 * responds to traffic correctly.
 *
 * A principle consideration for choosing a 'correct' manifest with which to serve traffic
 * is when to switch to a new (updated) version of the manifest. `Driver` is responsible
 * for periodically downloading fresh versions of the manifest from the server, staging
 * a new `VersionWorker` if the manifest has been updated, and deciding when to switch app
 * traffic from the old to the new manifest. A large part of `Driver`'s logic is devoted
 * to this update process.
 *
 * At a high level, updates follow this process:
 *
 * 1) When a new `Driver` is created (worker startup), it initializes into a READY state
 *    and then checks for an updated manifest from the network.
 *
 * 2) If such a manifest is found, the `Driver` creates a new `VersionWorker` and attempts
 *    to set it up successfully, updating files from the old `VersionWorker` currently
 *    serving traffic.
 *
 * 3) If that update is successful, the driver queues the new manifest as staged and
 *    enters an UPDATE_PENDING state.
 *
 * 4) On the next `fetch` event that meets all the criteria for an update, the `Driver`
 *    activates the stage manifest, begins serving traffic with the new `VersionWorker`,
 *    and instructs the old `VersionWorker to clear up.
 */
var Driver = (function () {
    function Driver(manifestUrl, plugins, scope, adapter, cache, events, fetcher, clock) {
        var _this = this;
        this.manifestUrl = manifestUrl;
        this.plugins = plugins;
        this.scope = scope;
        this.adapter = adapter;
        this.cache = cache;
        this.events = events;
        this.fetcher = fetcher;
        this.clock = clock;
        // The worker always starts in STARTUP.
        this.state = DriverState.STARTUP;
        // A hash of the pending manifest, if the worker is in an UPDATE_PENDING state.
        this.pendingUpdateHash = null;
        // The next available id for observable streams used to communicate with application tabs.
        this.streamId = 0;
        // A map of stream ids to `MessagePort`s that communicate with application tabs.
        this.streams = {};
        // The worker's lifecycle log, which is appended to when lifecycle events happen. This
        // is not ever cleared, but should not grow very large.
        this.lifecycleLog = [];
        // Stream IDs that are actively listening for update lifecycle events.
        this.updateListeners = [];
        this.id = driverId++;
        // Set up Promises for testing.
        this.ready = new Promise(function (resolve) { return _this.readyResolve = resolve; });
        this.updatePending = new Promise(function (resolve) { return _this.updatePendingResolve = resolve; });
        // All SW caching should go through this cache.
        this.scopedCache = new ScopedCache(this.cache, 'ngsw:');
        // Subscribe to all the service worker lifecycle events:
        events.install = function (event) {
            _this.lifecycle('install event');
            event.waitUntil(Promise.resolve()
                .then(function () { return _this.reset(); })
                .then(function () { return _this.scope.skipWaiting(); }));
        };
        events.activate = function (event) {
            _this.lifecycle('activate event');
            // Kick off the startup process right away, so the worker doesn't wait for fetch
            // events before getting a manifest and installing the app.
            if (!_this.init) {
                _this.startup();
            }
            // Take over all active pages. At this point the worker is still in STARTUP, so
            // all requests will fall back on the network.
            event.waitUntil(_this.scope.clients.claim());
        };
        events.fetch = function (event) {
            var req = event.request;
            // Handle the log event no matter what state the worker is in.
            if (req.url.endsWith('/ngsw.log')) {
                event.respondWith(_this
                    .status()
                    .then(function (status) { return _this.adapter.newResponse(JSON.stringify(status, null, 2)); }));
                return;
            }
            // Skip fetch events when in LAME state - no need to wait for init for this.
            // Since the worker doesn't call event.respondWith(), the browser will go to
            // the network for this request.
            if (_this.state === DriverState.LAME) {
                return;
            }
            // If this is the first request and the worker is in STARTUP, kick off the startup
            // process. This is a normal step for subsequent startups of the worker (during the
            // first one, the activate event usually kicks off the startup process).
            if (_this.state === DriverState.STARTUP && !_this.init) {
                _this.startup();
            }
            // Should not happen, but just in case, throw an error.
            if (!_this.init) {
                throw new Error("init Promise not present in state " + DriverState[_this.state]);
            }
            event.respondWith(_this
                .init
                .then(function () {
                switch (_this.state) {
                    case DriverState.READY:
                        // The worker is ready and this.active is set to a VersionWorker.
                        return _this.active.fetch(req);
                    case DriverState.UPDATE_PENDING:
                        // The worker is ready but has a pending update. Decide whether to activate
                        // the pending manifest before servicing the request.
                        return _this
                            .maybeUpdate(event.clientId)
                            .then(function () { return _this.active.fetch(req); });
                    case DriverState.INSTALLING:
                    case DriverState.LAME:
                        // Whether the worker is still INSTALLING or has freshly transitioned to a
                        // LAME state, serve the request with the network.
                        return _this.fetcher.request(req, true);
                    default:
                        // Shouldn't happen, but just be safe and serve the request from the network.
                        return _this.fetcher.request(req, true);
                }
            }));
        };
        events.message = function (event) {
            // Skip all events in the LAME state.
            if (_this.state === DriverState.LAME) {
                return;
            }
            // Start up if needed (see fetch above).
            if (_this.state === DriverState.STARTUP && !_this.init) {
                _this.startup();
            }
            if (!_this.init) {
                throw new Error("init Promise not present in state " + DriverState[_this.state]);
            }
            // Some sanity checks against the incoming message - is it intended for the worker?
            if (event.ports.length !== 1 || !event.data || !event.data.hasOwnProperty('$ngsw')) {
                return;
            }
            // Wait for initialization.
            _this.init.then(function () {
                // Did the worker reach a good state?
                if (_this.state !== DriverState.READY && _this.state !== DriverState.UPDATE_PENDING) {
                    // No - drop the message, it can't be handled until the worker is in a good state.
                    return;
                }
                // The message includes a MessagePort for sending responses. Set this up as a stream.
                var respond = event.ports[0];
                var id = _this.streamId++;
                _this.streams[id] = respond;
                // Send the id as the first response. This can be used by the client to notify of an
                // "unsubscription" to this request.
                respond.postMessage({ '$ngsw': true, 'id': id });
                // Handle the actual payload.
                _this.handleMessage(event.data, id);
            });
        };
        events.push = function (event) {
            // Skip all PUSH messages in the LAME state. Technically this isn't valid per the spec,
            // but better to ignore them than throw random errors.
            if (_this.state === DriverState.LAME) {
                return;
            }
            // Start up if needed (see fetch above).
            if (_this.state === DriverState.STARTUP && !_this.init) {
                _this.startup();
            }
            if (!_this.init) {
                throw new Error("init Promise not present in state " + DriverState[_this.state]);
            }
            Promise
                .all([
                _this.init,
                event.data.text(),
            ])
                .then(function (results) { return results[1]; })
                .then(function (data) {
                // Make sure the worker ended up in a good state after initialization.
                if (_this.state !== DriverState.READY && _this.state !== DriverState.UPDATE_PENDING) {
                    // If not, drop the push message. Again, not valid per the spec, but safer than attempting
                    // to handle and throwing errors.
                    return;
                }
                // Handle the message with the active VersionWorker.
                _this.active.push(data);
            });
        };
    }
    /**
     * Write a message to the lifecycle log.
     */
    Driver.prototype.lifecycle = function (msg) {
        this.lifecycleLog.push(msg);
    };
    /**
     * Attempt to reset the service worker to a pristine state, as if one had never been installed
     * before.
     *
     * This involves removing all of the caches that fall under the `ScopedCache` used by the
     * worker.
     */
    Driver.prototype.reset = function () {
        var _this = this;
        return this
            .scopedCache
            .keys()
            .then(function (keys) { return Promise
            .all(keys.map(function (key) { return _this.scopedCache.remove(key); }))
            .then(function () { return _this.lifecycle("reset removed " + keys.length + " ngsw: caches"); }); });
    };
    /**
     * Start up the worker.
     *
     * this.init is set up as a Promise that resolves when the worker exits the STARTUP state.
     * In the background, it also kicks off a check for a new version of the manifest.
     *
     * In the usual update flow, this means that the worker will first transition to READY,
     * and then to UPDATE_PENDING when the updated manifest is set up and ready to be served.
     */
    Driver.prototype.startup = function () {
        var _this = this;
        this.init = this.initialize();
        this.init.then(function () { return _this.checkForUpdate(); });
    };
    /**
     * Possibly switch to a pending manifest if it's safe to do so.
     *
     * Safety is determined by whether there are other application tabs open, since they may
     * be depending on the worker to serve lazily-loaded js from the previous version of the
     * app, or it may be using a shared IndexedDB across all the tabs that can't be updated
     * yet, etc.
     */
    Driver.prototype.maybeUpdate = function (clientId) {
        var _this = this;
        return this
            .scope
            .clients
            .matchAll()
            .then(function (clients) {
            // Currently, the only criteria is that this must be a fresh tab (no current
            // clients).
            if (clients.length !== 0) {
                return null;
            }
            return _this.doUpdate();
        });
    };
    /**
     * Switch to the staged worker (if any).
     *
     * After updating, the worker will be in state READY, always. If a staged manifest
     * was present and validated, it will be set as active.
     *
     * If `expectVersion` is set but the staged manifest does not match the expected
     * version, the update is skipped and the result resolves to false.
     */
    Driver.prototype.doUpdate = function (expectVersion) {
        var _this = this;
        return this
            .fetchManifestFromCache('staged')
            .then(function (manifest) {
            // If no staged manifest exists in the cache, just transition to READY now.
            if (!manifest) {
                _this.transition(DriverState.READY);
                return false;
            }
            // If a particular version is expected 
            if (!!expectVersion && manifest._hash !== expectVersion) {
                return false;
            }
            return _this
                .openManifest(manifest)
                .then(function (worker) { return _this
                .clearStaged()
                .then(function () { return worker ? _this.setManifest(manifest, 'active') : null; })
                .then(function () {
                if (worker) {
                    // Set this.active to the new worker.
                    var oldActive_1 = _this.active;
                    _this.active = worker;
                    // At this point, the old worker can clean up its caches as they're no longer
                    // needed.
                    _this
                        .cleanup(oldActive_1)
                        .then(function () { return _this.lifecycle("cleaned up old version " + oldActive_1.manifest._hash); });
                    // Notify update listeners that an update has occurred.
                    _this.updateListeners.forEach(function (id) {
                        _this.sendToStream(id, {
                            type: 'activation',
                            version: manifest._hash,
                        });
                    });
                    _this.lifecycle("updated to manifest " + manifest._hash);
                }
                // Regardless of whether the manifest successfully validated, it is no longer
                // a pending update, so transition to READY.
                _this.transition(DriverState.READY);
                return true;
            }); });
        });
    };
    /**
     * Clear the currently active manifest (if any).
     */
    Driver.prototype.clearActive = function () {
        // Fail if the worker is in a state which expects an active manifest to be present.
        if (this.state === DriverState.READY || this.state === DriverState.UPDATE_PENDING) {
            return Promise.reject("Cannot clear the active manifest when it's being used.");
        }
        return this.scopedCache.invalidate('active', this.manifestUrl);
    };
    /**
     * Clear the currently staged manifest (if any).
     */
    Driver.prototype.clearStaged = function () {
        return this.scopedCache.invalidate('staged', this.manifestUrl);
    };
    /**
     * Check the network for a new version of the manifest, and stage it if possible.
     *
     * This will request a new copy of the manifest from the network and compare it with
     * both the active manifest and any staged manifest if present.
     *
     * If the manifest is newer than the active or the staged manifest, it will be loaded
     * and the setup process run for all installed plugins. If it passes that process, it
     * will be set as the staged manifest, and the worker state will be set to UPDATE_PENDING.
     *
     * checkForUpdate() returns a boolean indicating whether a staged update is pending,
     * regardless of whether this particular call caused the update to become staged.
     */
    Driver.prototype.checkForUpdate = function () {
        var _this = this;
        // If the driver isn't in a good serving state, there is no reasonable course of action
        // if an update would be found, so don't check.
        if (this.state !== DriverState.READY && this.state !== DriverState.UPDATE_PENDING) {
            this.lifecycle("skipping update check, in state " + DriverState[this.state]);
            return Promise.resolve(false);
        }
        // If the worker is in the UPDATE_PENDING state, then no need to check, there is an update.
        if (this.state === DriverState.UPDATE_PENDING) {
            return Promise.resolve(true);
        }
        return Promise
            .all([
            this.fetchManifestFromCache('active'),
            this.fetchManifestFromCache('staged'),
            this.fetchManifestFromNetwork(),
        ])
            .then(function (manifests) {
            var active = manifests[0], staged = manifests[1], network = manifests[2];
            // If the request for a manifest from the network was unsuccessful, there's no
            // way to tell if an update is available, so skip.
            if (!network) {
                // Even if the network request failed, there could still be a pending manifest.
                // This technically shouldn't happen since the worker should have been placed in
                // the UPDATE_PENDING state by initialize(), but this is here for safety.
                if (!!staged) {
                    // If there is a staged manifest, transition to UPDATE_PENDING.
                    _this.pendingUpdateHash = staged._hash;
                    _this.transition(DriverState.UPDATE_PENDING);
                    return true;
                }
                else {
                    return false;
                }
            }
            // If the network manifest is currently the active manifest, no update is available.
            if (!!active && active._hash === network._hash) {
                return false;
            }
            // If the network manifest is already staged, just go to UPDATE_PENDING. Theoretically
            // this shouldn't happen since initialize() should have already transitioned to
            // UPDATE_PENDING, but as above, this is here for safety.
            if (!!staged && staged._hash === network._hash) {
                _this.lifecycle("network manifest " + network._hash + " is already staged");
                _this.pendingUpdateHash = staged._hash;
                _this.transition(DriverState.UPDATE_PENDING);
                return true;
            }
            // A Promise which may do extra work before the update.
            var start = Promise.resolve();
            // If there is a staged manifest, then before setting up the update, remove it.
            if (!!staged) {
                _this.lifecycle("staged manifest " + staged._hash + " is old, removing");
                start = _this.clearStaged();
            }
            return start
                .then(function () { return _this.setupManifest(network, _this.active); })
                .then(function () { return _this.setManifest(network, 'staged'); })
                .then(function () {
                // Finally, transition to UPDATE_PENDING to indicate updates should be checked.
                _this.pendingUpdateHash = network._hash;
                _this.transition(DriverState.UPDATE_PENDING);
                _this.lifecycle("staged update to " + network._hash);
                return true;
            });
        });
    };
    /**
     * Transitions the worker out of the STARTUP state, by either serving the active
     * manifest or installing from the network if one is not present.
     *
     * Initialization can fail, which will result in the worker ending up in a LAME
     * state where it effectively disables itself until the next startup.
     *
     * This function returns a Promise which, when resolved, guarantees the worker is
     * no longer in a STARTUP state.
     */
    Driver.prototype.initialize = function () {
        var _this = this;
        // Fail if the worker is initialized twice.
        if (!!this.init) {
            throw new Error("double initialization!");
        }
        // Initialization is only valid in the STARTUP state.
        if (this.state !== DriverState.STARTUP) {
            return Promise.reject(new Error("driver: initialize() called when not in STARTUP state"));
        }
        return Promise
            .all([
            this.fetchManifestFromCache('active'),
            this.fetchManifestFromCache('staged'),
        ])
            .then(function (manifests) {
            var active = manifests[0], staged = manifests[1];
            if (!active) {
                // If there's no active manifest, then a network installation is required.
                _this.transition(DriverState.INSTALLING);
                // Installing from the network is asynchronous, but initialization doesn't block on
                // it. Therefore the Promise returned from doInstallFromNetwork() is ignored.
                _this.doInstallFromNetwork();
                return null;
            }
            return _this
                .openManifest(active)
                .then(function (worker) {
                if (!worker) {
                    // The active manifest is somehow invalid. Nothing to do but enter a LAME state
                    // and remove it, and hope the next time the worker is initialized, a fresh copy
                    // will be installed from the network without issues.
                    _this.transition(DriverState.LAME);
                    return _this.clearActive();
                }
                _this.lifecycle("manifest " + active._hash + " activated");
                _this.active = worker;
                // If a staged manifest exist, go to UPDATE_PENDING instead of READY.
                if (!!staged) {
                    if (staged._hash === active._hash) {
                        _this.lifecycle("staged manifest " + staged._hash + " is already active, cleaning it up");
                        _this.transition(DriverState.READY);
                        return _this.clearStaged();
                    }
                    else {
                        _this.lifecycle("staged manifest " + staged._hash + " present at initialization");
                        _this.pendingUpdateHash = staged._hash;
                        _this.transition(DriverState.UPDATE_PENDING);
                        return null;
                    }
                }
                _this.transition(DriverState.READY);
            });
        });
    };
    /**
     * Fetch and install a manifest from the network.
     *
     * If successful, the manifest will become active and the worker will finish in state
     * READY. If any errors are encountered, the worker will transition to a LAME state.
     */
    Driver.prototype.doInstallFromNetwork = function () {
        var _this = this;
        return this
            .fetchManifestFromNetwork()
            .then(function (manifest) {
            if (!manifest) {
                // If it wasn't successful, there's no graceful way to recover, so go to a
                // LAME state.
                _this.lifecycle('no network manifest found to install from');
                _this.transition(DriverState.LAME);
                return null;
            }
            return _this
                .setupManifest(manifest, null)
                .then(function (worker) {
                if (!worker) {
                    _this.lifecycle('network manifest setup failed');
                    _this.transition(DriverState.LAME);
                    return null;
                }
                _this
                    .setManifest(manifest, 'active')
                    .then(function () {
                    // Set this.active and transition to READY.
                    _this.active = worker;
                    _this.lifecycle("installed version " + manifest._hash + " from network");
                    _this.transition(DriverState.READY);
                });
            });
        });
    };
    /**
     * Fetch a cached copy of the manifest.
     */
    Driver.prototype.fetchManifestFromCache = function (cache) {
        var _this = this;
        return this
            .scopedCache
            .load(cache, this.manifestUrl)
            .then(function (resp) { return _this.manifestFromResponse(resp); });
    };
    /**
     * Fetch a copy of the manifest from the network.
     *
     * Resolves with null on a failure.
     */
    Driver.prototype.fetchManifestFromNetwork = function () {
        var _this = this;
        return this
            .fetcher
            .refresh(this.manifestUrl)
            .then(function (resp) { return _this.manifestFromResponse(resp); })
            .catch(function () { return null; });
    };
    /**
     * Parse the given `Response` and return a `Manifest` object.
     */
    Driver.prototype.manifestFromResponse = function (resp) {
        if (!resp || resp.status !== 200) {
            return null;
        }
        return resp.text().then(function (body) { return parseManifest(body); });
    };
    /**
     * Store the given `Manifest` in the given cache.
     */
    Driver.prototype.setManifest = function (manifest, cache) {
        return this.scopedCache.store(cache, this.manifestUrl, this.adapter.newResponse(manifest._json));
    };
    /**
     * Construct a `VersionWorker` for the given manifest.
     *
     * This worker will have all of the plugins specified during the bootstrap process installed,
     * but not yet initialized (setup()).
     */
    Driver.prototype.workerFromManifest = function (manifest) {
        var plugins = [];
        var worker = new VersionWorkerImpl(this, this.scope, manifest, this.adapter, new ScopedCache(this.scopedCache, "manifest:" + manifest._hash + ":"), this.clock, this.fetcher, plugins);
        plugins.push.apply(plugins, this.plugins.map(function (factory) { return factory(worker); }));
        return worker;
    };
    /**
     * Instantiates a `VersionWorker` from a manifest and runs it through its setup process.
     *
     * Optionally, the worker can be directed to update from an existing `VersionWorker`
     * instead of performing a fresh setup. This can save time if resources have not changed
     * between the old and new manifests.
     */
    Driver.prototype.setupManifest = function (manifest, existing) {
        if (existing === void 0) { existing = null; }
        var worker = this.workerFromManifest(manifest);
        return worker
            .setup(existing)
            .then(function () { return worker; });
    };
    /**
     * Instantiates a `VersionWorker` from a manifest that was previously set up according
     * by `setupManifest`.
     *
     * The worker will be validated (its caches checked against the manifest to assure all
     * resources listed are cached properly). If it passes validation, the returned Promise
     * will resolve with the worker instance, if not it resolves with `null`.
     */
    Driver.prototype.openManifest = function (manifest) {
        var _this = this;
        var worker = this.workerFromManifest(manifest);
        return worker
            .validate()
            .then(function (valid) {
            if (!valid) {
                // The worker wasn't valid - something was missing from the caches.
                _this.lifecycle("cached version " + manifest._hash + " not valid");
                // Attempt to recover by cleaning up the worker. This should allow it to be
                // freshly installed the next time the `Driver` starts.
                return _this
                    .cleanup(worker)
                    .then(function () { return null; });
            }
            return worker;
        });
    };
    /**
     * Run a `VersionWorker` through its cleanup process, resolving when it completes.
     */
    Driver.prototype.cleanup = function (worker) {
        return worker
            .cleanup()
            .reduce(function (prev, curr) { return prev.then(function (resp) { return curr(); }); }, Promise.resolve(null));
    };
    /**
     * Fetch the status of the `Driver`, including current state and lifecycle messages.
     */
    Driver.prototype.status = function () {
        return Promise.resolve({
            state: DriverState[this.state],
            lifecycleLog: this.lifecycleLog,
        });
    };
    /**
     * Transition into a new state.
     *
     * `transition` logs the transition, and also handles resolving several promises useful
     * for testing the more asynchronous parts of the `Driver` which aren't exposed via the
     * more public API.
     */
    Driver.prototype.transition = function (state) {
        var _this = this;
        this.lifecycle("transition from " + DriverState[this.state] + " to " + DriverState[state]);
        this.state = state;
        // If the `DRIVER` entered the READY state, resolve the ready Promise.
        if (state === DriverState.READY && this.readyResolve !== null) {
            var resolve = this.readyResolve;
            this.readyResolve = null;
            resolve();
        }
        // If the driver entered the UPDATE_PENDING state, resolve the update pending Promise,
        // and reset the ready Promise.
        if (state === DriverState.UPDATE_PENDING && this.updatePendingResolve !== null) {
            this.ready = new Promise(function (resolve) { return _this.readyResolve = resolve; });
            var resolve = this.updatePendingResolve;
            this.updatePendingResolve = null;
            resolve();
        }
        // If the driver entered the UPDATE_PENDING state, notify all update subscribers
        // about the pending update.
        if (state === DriverState.UPDATE_PENDING && this.pendingUpdateHash !== null) {
            this.updateListeners.forEach(function (id) { return _this.sendToStream(id, {
                type: 'pending',
                version: _this.pendingUpdateHash,
            }); });
        }
        else if (state !== DriverState.UPDATE_PENDING) {
            // Reset the pending update hash if not transitioning to UPDATE_PENDING.
            this.pendingUpdateHash = null;
        }
    };
    /**
     * Process a `postMessage` received by the worker.
     */
    Driver.prototype.handleMessage = function (message, id) {
        var _this = this;
        // If the `Driver` is not in a known good state, nothing to do but exit.
        if (this.state !== DriverState.READY && this.state !== DriverState.UPDATE_PENDING) {
            this.lifecycle("can't handle message in state " + DriverState[this.state]);
            return;
        }
        // The message has a 'cmd' key which determines the action the `Driver` will take.
        // Some commands are handled directly by the `Driver`, the rest are passed on to the
        // active `VersionWorker` to be handled by a plugin.
        switch (message['cmd']) {
            // A ping is a request for the service worker to assert it is up and running by
            // completing the "Observable" stream.
            case 'ping':
                this.lifecycle("responding to ping on " + id);
                this.closeStream(id);
                break;
            // An update message is a request for the service worker to keep the application
            // apprised of any pending update events, such as a new manifest becoming pending.
            case 'update':
                this.updateListeners.push(id);
                // Since this is a new subscriber, check if there's a pending update now and
                // deliver an initial event if so.
                if (this.state === DriverState.UPDATE_PENDING && this.pendingUpdateHash !== null) {
                    this.sendToStream(id, {
                        type: 'pending',
                        version: this.pendingUpdateHash,
                    });
                }
                break;
            // Check for a pending update, fetching a new manifest from the network if necessary,
            // and return the result as a boolean value beore completing.
            case 'checkUpdate':
                this.checkForUpdate().then(function (value) {
                    _this.sendToStream(id, value);
                    _this.closeStream(id);
                });
                break;
            case 'activateUpdate':
                this.doUpdate(message['version'] || undefined).then(function (success) {
                    _this.sendToStream(id, success);
                    _this.closeStream(id);
                });
                break;
            // 'cancel' is a special command that the other side has unsubscribed from the stream.
            // Plugins may choose to take action as a result.
            case 'cancel':
                // Attempt to look up the stream the client is requesting to cancel.
                var idToCancel = message['id'];
                if (!this.streams.hasOwnProperty(id)) {
                    // Not found - nothing to do but exit.
                    return;
                }
                // Notify the active `VersionWorker` that the client has unsubscribed.
                this.active.messageClosed(id);
                // This listener may have been a subscriber to 'update' events.
                this.maybeRemoveUpdateListener(id);
                // Finally, remove the stream.
                delete this.streams[id];
                break;
            // A request to stream the service worker debugging log. Only one of these is valid
            // at a time.
            case 'log':
                LOGGER.messages = function (message) {
                    _this.sendToStream(id, message);
                };
                break;
            // If the command is unknown, delegate to the active `VersionWorker` to handle it.
            default:
                this.active.message(message, id);
        }
    };
    /**
     * Remove the given stream id from the set of subscribers to update events, if present.
     */
    Driver.prototype.maybeRemoveUpdateListener = function (id) {
        var idx = this.updateListeners.indexOf(id);
        if (idx !== -1) {
            this.updateListeners.splice(idx, 1);
        }
    };
    /**
     * Post a message to the stream with the given id.
     */
    Driver.prototype.sendToStream = function (id, message) {
        if (!this.streams.hasOwnProperty(id)) {
            return;
        }
        this.streams[id].postMessage(message);
    };
    /**
     * Complete the stream with the given id.
     *
     * Per the protocol between the service worker and client tabs, a completion is modeled as
     * a null message.
     */
    Driver.prototype.closeStream = function (id) {
        if (!this.streams.hasOwnProperty(id)) {
            return;
        }
        this.streams[id].postMessage(null);
        delete this.streams[id];
    };
    return Driver;
}());
export { Driver };
//# sourceMappingURL=driver.js.map