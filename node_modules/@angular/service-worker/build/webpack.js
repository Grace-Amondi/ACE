"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var crypto = require('crypto');
/**
 * Webpack plugin that generates a basic Angular service worker manifest.
 */
var AngularServiceWorkerPlugin = (function () {
    function AngularServiceWorkerPlugin(config) {
        this.manifestFile = (config && config.manifestFile) || 'ngsw-manifest.json';
        this.manifestKey = (config && config.manifestKey) || 'static';
        this.baseHref = (config && config.baseHref) || '/';
        if (!this.baseHref.endsWith('/')) {
            this.baseHref += '/';
        }
    }
    AngularServiceWorkerPlugin.prototype.apply = function (compiler) {
        var _this = this;
        // Determine the URL prefix under which all files will be served.
        compiler.plugin('emit', function (compilation, callback) {
            // Manifest into which assets to be fetched will be recorded. This will either
            // be read from the existing template or created fresh.
            var manifest = {};
            // Look for an existing manifest. If there is one, parse it.
            try {
                if (compilation.assets.hasOwnProperty(_this.manifestFile)) {
                    manifest = JSON.parse(compilation.assets[_this.manifestFile].source().toString());
                }
            }
            catch (err) {
                throw new Error("Error reading existing service worker manifest: " + err);
            }
            // Throw if the manifest already has this particular key.
            if (manifest.hasOwnProperty(_this.manifestKey) &&
                !manifest[_this.manifestKey].hasOwnProperty('_generatedFromWebpack')) {
                throw new Error("Manifest already contains key: " + _this.manifestKey);
            }
            // Look for ignored patterns in the manifest.
            var ignored = [];
            var ignoreKey = _this.manifestKey + ".ignore";
            if (manifest.hasOwnProperty(ignoreKey)) {
                ignored.push.apply(ignored, manifest[ignoreKey]
                    .map(function (regex) { return new RegExp(regex); }));
                delete manifest[ignoreKey];
            }
            // Map of urls to hashes.
            var urls = {};
            manifest[_this.manifestKey] = { urls: urls, _generatedFromWebpack: true };
            // Go through every asset in the compilation and include it in the manifest,
            // computing a hash for proper versioning.
            Object
                .keys(compilation.assets)
                .filter(function (key) { return key !== _this.manifestFile; })
                .forEach(function (key) {
                var url = "" + _this.baseHref + key;
                if (ignored.some(function (regex) { return regex.test(url); })) {
                    return;
                }
                urls[url] = sha1(compilation.assets[key].source());
            });
            // Serialize the manifest to a buffer, and include (or overwrite) it in the assets.
            var serialized = new Buffer(JSON.stringify(manifest, null, 2));
            compilation.assets[_this.manifestFile] = {
                source: function () { return serialized; },
                size: function () { return serialized.length; },
            };
            callback();
        });
    };
    return AngularServiceWorkerPlugin;
}());
exports.AngularServiceWorkerPlugin = AngularServiceWorkerPlugin;
function sha1(buffer) {
    var hash = crypto.createHash('sha1');
    hash.update(buffer);
    return hash.digest('hex');
}
//# sourceMappingURL=webpack.js.map