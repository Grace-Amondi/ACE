import { Injectable, NgZone } from '@angular/core';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Observable } from 'rxjs/Observable';
import { fromByteArray } from 'base64-js';
export function doAsync(fn) {
    return function (obs) { return obs
        .concatMap(function (value) { return fn(value)
        .reduce(function () { return value; }, value); }); };
}
import 'rxjs/add/observable/concat';
import 'rxjs/add/observable/defer';
import 'rxjs/add/observable/empty';
import 'rxjs/add/observable/from';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/observable/merge';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/timer';
import 'rxjs/add/operator/concatMap';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/expand';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/first';
import 'rxjs/add/operator/let';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/publishReplay';
import 'rxjs/add/operator/reduce';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/take';
import 'rxjs/add/operator/takeWhile';
function fromPromise(promiseFn) {
    return Observable.create(function (observer) {
        promiseFn()
            .then(function (v) { return observer.next(v); })
            .then(function () { return observer.complete(); })
            .catch(function (err) { return observer.error(err); });
    });
}
// A push notification registration, including the endpoint URL and encryption keys.
var NgPushRegistration = (function () {
    function NgPushRegistration(ps) {
        this.ps = ps;
    }
    // Get the authentication key
    NgPushRegistration.prototype.auth = function () {
        return this.key('auth');
    };
    NgPushRegistration.prototype.key = function (method) {
        if (method === void 0) { method = 'p256dh'; }
        return fromByteArray(new Uint8Array(this.ps.getKey(method)));
    };
    Object.defineProperty(NgPushRegistration.prototype, "url", {
        get: function () {
            return this.ps.endpoint;
        },
        enumerable: true,
        configurable: true
    });
    NgPushRegistration.prototype.toJSON = function () {
        return this.ps.toJSON();
    };
    NgPushRegistration.prototype.unsubscribe = function () {
        var _this = this;
        // TODO: switch to Observable.fromPromise when it's not broken.
        return fromPromise(function () { return _this.ps.unsubscribe(); });
    };
    return NgPushRegistration;
}());
export { NgPushRegistration };
var NgServiceWorker = (function () {
    function NgServiceWorker(zone) {
        var _this = this;
        this.zone = zone;
        // Always returns the current controlling worker, or undefined if there isn't one.
        this.controllingWorker = new BehaviorSubject(undefined);
        // Extract a typed version of navigator.serviceWorker.
        this.container = (typeof navigator === 'object') && navigator['serviceWorker'];
        if (!!this.container) {
            // Final Observable that will always give back the current controlling worker,
            // and follow changes over time.
            Observable
                .concat(
            // Current controlling worker (if any).
            Observable.of(this.container.controller), 
            // Future changes of the controlling worker.
            Observable
                .fromEvent(this.container, 'controllerchange')
                .map(function (_) { return _this.container.controller; }))
                .subscribe(function (worker) { return _this.controllingWorker.next(worker); }, function (err) { return _this.controllingWorker.error(err); }, function () { return _this.controllingWorker.complete(); });
        }
        // To make one-off calls to the worker, awaitSingleControllingWorker waits for
        // a controlling worker to exist.
        this.awaitSingleControllingWorker = this
            .controllingWorker
            .filter(function (worker) { return !!worker; })
            .take(1);
        // Setup the push Observable as a broadcast mechanism for push notifications.
        this.push = Observable
            .defer(function () { return _this.send({ cmd: 'push' }); })
            .share();
        // Setup the updates Observable as a broadcast mechanism for update notifications.
        this.updates = Observable
            .defer(function () { return _this.send({ cmd: 'update' }); })
            .share();
    }
    NgServiceWorker.prototype.registrationForWorker = function () {
        var _this = this;
        return function (obs) { return obs
            .switchMap(function (worker) { return fromPromise(function () { return _this.container.getRegistrations(); })
            .expand(function (regs) { return Observable.from(regs); })
            .filter(function (reg) { return reg.active === worker; })
            .take(1); }); };
    };
    // Sends a single message to the worker, and awaits one (or more) responses.
    NgServiceWorker.prototype.sendToWorker = function (worker, message) {
        var _this = this;
        // A MessageChannel is sent with the message so responses can be correlated.
        var channel = new MessageChannel();
        // Observe replies.
        var result = new Observable(function (observer) {
            var cancelId = null;
            var listener = function (event) {
                var data = event.data;
                if (!!data && typeof data === "object" && data.hasOwnProperty('$ngsw') && data.hasOwnProperty('id')) {
                    cancelId = data['id'];
                }
                else if (data === null) {
                    observer.complete();
                    channel.port1.removeEventListener('message', listener);
                    return;
                }
                else {
                    observer.next(data);
                }
            };
            channel.port1.addEventListener('message', listener);
            return function () {
                channel.port1.removeEventListener('message', listener);
                _this.sendToWorker(worker, { cmd: 'cancel', id: cancelId });
            };
        })
            .takeWhile(function (v) { return !!v; })
            .publishReplay();
        // Connecting actually creates the event subscription and starts recording
        // for replay.
        result.connect();
        // Start receiving message(s).
        channel.port1.start();
        // Set a magic value in the message.
        message['$ngsw'] = true;
        worker.postMessage(message, [channel.port2]);
        return result;
    };
    // Send a message to the current controlling worker, waiting for one if needed.
    NgServiceWorker.prototype.send = function (message) {
        var _this = this;
        return this
            .awaitSingleControllingWorker
            .switchMap(function (worker) { return _this.sendToWorker(worker, message); });
    };
    // Send a 'ping' to the worker. The returned Observable will complete when the worker
    // acknowledges the message. This provides a test that the worker is alive and listening.
    NgServiceWorker.prototype.ping = function () {
        return this.send({
            cmd: 'ping'
        });
    };
    NgServiceWorker.prototype.log = function () {
        return this.send({
            cmd: 'log'
        });
    };
    NgServiceWorker.prototype.activateUpdate = function (version) {
        return this.send({
            cmd: 'activateUpdate',
            version: version,
        });
    };
    NgServiceWorker.prototype.registerForPush = function (pushOptions) {
        var _this = this;
        if (pushOptions === void 0) { pushOptions = {}; }
        return this
            .awaitSingleControllingWorker
            .let(this.registrationForWorker())
            .map(function (worker) { return worker.pushManager; })
            .switchMap(function (pushManager) {
            // Create an Observable to wrap the Promises of the PushManager API.
            // TODO: switch to Observable.fromPromise when it's not broken.
            // This is extracted as a variable so Typescript infers types correctly.
            var reg = Observable.create(function (observer) {
                // Function that maps subscriptions to an Angular-specific representation.
                var regFromSub = function (sub) { return new NgPushRegistration(sub); };
                pushManager
                    .getSubscription()
                    .then(function (sub) {
                    // If there is one, we don't need to register, just return it.
                    if (!!sub) {
                        return regFromSub(sub);
                    }
                    // No existing subscription, register (with userVisibleOnly: true).
                    var options = {
                        userVisibleOnly: true,
                    };
                    if (pushOptions.applicationServerKey) {
                        var key = atob(pushOptions
                            .applicationServerKey
                            .replace(/_/g, '/')
                            .replace(/-/g, '+'));
                        var applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));
                        for (var i = 0; i < key.length; i++) {
                            applicationServerKey[i] = key.charCodeAt(i);
                        }
                        options['applicationServerKey'] = applicationServerKey;
                    }
                    return pushManager
                        .subscribe(options)
                        .then(regFromSub);
                })
                    .then(function (sub) { return _this.zone.run(function () { return observer.next(sub); }); })
                    .then(function () { return _this.zone.run(function () { return observer.complete(); }); })
                    .catch(function (err) { return _this.zone.run(function () { return observer.error(err); }); });
            });
            return reg;
        });
    };
    NgServiceWorker.prototype.checkForUpdate = function () {
        return this.send({ cmd: 'checkUpdate' });
    };
    return NgServiceWorker;
}());
export { NgServiceWorker };
NgServiceWorker.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgServiceWorker.ctorParameters = function () { return [
    { type: NgZone, },
]; };
//# sourceMappingURL=comm.js.map