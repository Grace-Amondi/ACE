import { cacheFromNetworkOp, copyExistingOrFetchOp, deleteCacheOp, fetchFromCacheInstruction, LOG } from '@angular/service-worker/worker';
export function StaticContentCache(options) {
    var manifestKey = (options && options.manifestKey) || 'static';
    return function (worker) { return new StaticContentCacheImpl(worker, manifestKey); };
}
var StaticContentCacheImpl = (function () {
    function StaticContentCacheImpl(worker, key) {
        this.worker = worker;
        this.key = key;
        this.cacheKey = key === 'static' ? key : "static:" + key;
    }
    Object.defineProperty(StaticContentCacheImpl.prototype, "staticManifest", {
        get: function () {
            return this.worker.manifest[this.key];
        },
        enumerable: true,
        configurable: true
    });
    StaticContentCacheImpl.prototype.shouldCacheBustFn = function () {
        var shouldCacheBust = function (url) { return true; };
        if (!!this.staticManifest.versioned && Array.isArray(this.staticManifest.versioned)) {
            var regexes_1 = this.staticManifest.versioned.map(function (expr) { return new RegExp(expr); });
            shouldCacheBust = function (url) { return !regexes_1.some(function (regex) { return regex.test(url); }); };
        }
        return shouldCacheBust;
    };
    StaticContentCacheImpl.prototype.setup = function (operations) {
        var _this = this;
        var shouldCacheBust = this.shouldCacheBustFn();
        operations.push.apply(operations, Object
            .keys(this.staticManifest.urls)
            .map(function (url) { return function () {
            return _this
                .worker
                .cache
                .load(_this.cacheKey, url)
                .then(function (resp) {
                if (!!resp) {
                    LOG.technical("setup(" + _this.cacheKey + ", " + url + "): no need to refresh " + url + " in the cache");
                    return null;
                }
                LOG.technical("setup(" + _this.cacheKey + ", " + url + "): caching from network");
                return cacheFromNetworkOp(_this.worker, url, _this.cacheKey, shouldCacheBust(url))();
            });
        }; }));
    };
    StaticContentCacheImpl.prototype.update = function (operations, previous) {
        var _this = this;
        var shouldCacheBust = this.shouldCacheBustFn();
        operations.push.apply(operations, Object
            .keys(this.staticManifest.urls)
            .map(function (url) {
            var hash = _this.staticManifest.urls[url];
            var previousHash = previous.staticManifest.urls[url];
            if (previousHash === hash) {
                LOG.technical("update(" + _this.cacheKey + ", " + url + "): no need to refresh " + url + " in the cache");
                return copyExistingOrFetchOp(previous.worker, _this.worker, url, _this.cacheKey);
            }
            else {
                LOG.technical("update(" + _this.cacheKey + ", " + url + "): caching from network");
                return cacheFromNetworkOp(_this.worker, url, _this.cacheKey, shouldCacheBust(url));
            }
        }));
    };
    StaticContentCacheImpl.prototype.fetch = function (req) {
        return fetchFromCacheInstruction(this.worker, req, this.cacheKey);
    };
    StaticContentCacheImpl.prototype.cleanup = function (operations) {
        operations.push(deleteCacheOp(this.worker, this.cacheKey));
    };
    StaticContentCacheImpl.prototype.validate = function () {
        var _this = this;
        return Promise
            .all(Object
            .keys(this.staticManifest.urls)
            .map(function (url) { return _this.worker.cache.load(_this.cacheKey, url); }))
            .then(function (resps) { return resps.every(function (resp) { return !!resp && resp.ok; }); });
    };
    return StaticContentCacheImpl;
}());
export { StaticContentCacheImpl };
//# sourceMappingURL=index.js.map