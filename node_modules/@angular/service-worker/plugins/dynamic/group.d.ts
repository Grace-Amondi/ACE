import { NgSwCache, NgSwAdapter, UrlMatcher, Clock } from '../../worker';
import { GroupManifest } from './manifest';
/**
 * Metadata that's tracked for every entry in the cache.
 */
export interface EntryMetadata {
    /**
     * Number of times this entry has been accessed. Used for LFU.
     */
    accessCount: number;
    /**
     * Timestamp (Date.now) since this cached request was last accessed. Used for LRU.
     */
    accessedTs: number;
    /**
     * Timestamp (Date.now) since this cached request was first added. Used for FIFO.
     */
    addedTs: number;
}
/**
 * Map of URLs to metadata for those URLs.
 */
export interface EntryMetadataMap {
    [url: string]: EntryMetadata;
}
/**
 * A function which, when called, effects a side effect that may complete
 * asynchronously.
 */
export declare type SideEffectFn = () => Promise<any>;
/**
 * A potential `Response`, with an optional side effect function. Side effects
 * are used to update metadata and perform other operations outside of the critical
 * path for the request.
 *
 * If response is `null`, then there was no response available for this request.
 */
export interface ResponseWithSideEffect {
    /**
     * The response, or `null` if none existed for the request.
     */
    response: Response | null;
    /**
     * Age of this response, if available.
     */
    cacheAge?: number;
    /**
     * An optional function which, when executed, applies an asynchronous side effect.
     */
    sideEffect?: SideEffectFn;
}
/**
 * Optionally applies a side effect, returning a `Promise` which waits for the
 * side effect to be applied if it exists, or resolves immediately if not.
 */
export declare function maybeRun(sideEffect: SideEffectFn | null): Promise<any>;
/**
 * A strategy that makes use of the cache information in the `DynamicGroup` to
 * optimize the loading of `Request`s.
 */
export interface DynamicStrategy {
    /**
     * The strategy name, which will be matched against "optimizeFor" configuration
     * in dynamic cache configurations.
     */
    readonly name: string;
    /**
     * Applies the strategy to a `Request` and returns an asynchronous response with an
     * optional side effect.
     *
     * The given delegate is used to forward the request to the remainder of the chain
     * in the event the strategy cannot or elects not to use a cached response.
     */
    fetch(group: DynamicGroup, req: Request, delegate: () => Promise<Response>): Promise<ResponseWithSideEffect>;
}
/**
 * Map of strategy names to implementations.
 */
export interface DynamicStrategyMap {
    [strategy: string]: DynamicStrategy;
}
/**
 * Represents a specific cache group with a single policy.
 */
export declare class DynamicGroup {
    /**
     * A queue of cached URLs, sorted according to the caching configuration (fifo,
     * lfu, or lru). This is maintained in memory only, and reconstructed by `open`
     * when loading from saved state.
     */
    private queue;
    /**
     * Metadata for entries in this group's cache. Only URLs which exist in `queue`
     * should have entries in this metadata map.
     *
     * The metadata map is mirrored to a 'metadata' cache entry under this group's
     * scoped cache, keyed by the request.
     */
    private metadata;
    /**
     * The optimization strategy used for requests in this group. The actual work
     * of determining whether to used cached responses or continue to the network
     * is done by the `DynamicStrategy`, not the `DynamicGroup`.
     */
    private strategy;
    /**
     * The user-provided manifest which configures the behavior of this dynamic
     * caching group.
     */
    config: GroupManifest;
    /**
     * Facade which enables unit testing of the cache group.
     */
    private adapter;
    /**
     * A cache scoped to this particular dynamic group.
     */
    private cache;
    /**
     * Matchers that will detect URLs which should be handled by this group.
     */
    private matchers;
    /**
     * Clock which enables easy unit testing of `DynamicGroup`'s cache expiration
     * operations through mocking of the current time.
     */
    clock: Clock;
    /**
     * Consumers should use `DynamicGroup.open` instead.
     */
    constructor(strategy: DynamicStrategy, config: GroupManifest, adapter: NgSwAdapter, cache: NgSwCache, matchers: UrlMatcher[], metadata: EntryMetadataMap, clock: Clock);
    /**
     * Constructs a new `DynamicGroup`, based on the given manifest. If this group has
     * never existed before, it will be empty. If it has, the existing metadata will be
     * read out of
     */
    static open(config: GroupManifest, adapter: NgSwAdapter, delegateCache: NgSwCache, clock: Clock, strategies: DynamicStrategyMap): Promise<DynamicGroup>;
    /**
     * Match a `Request` against the URL patterns configured for this group.
     */
    matches(req: Request): boolean;
    /**
     * A comparison function for FIFO expiration, that compares two URLs by time added.
     */
    private fifoCompare(urlA, urlB);
    /**
     * A comparison function for LFU expiration, that compares two URLs by access count.
     */
    private lfuCompare(urlA, urlB);
    /**
     * A comparison function for LRU expiration, that compares two URLs by time accessed.
     */
    private lruCompare(urlA, urlB);
    /**
     * Fetch a given request from the cache only.
     */
    fetchFromCache(req: Request): Promise<ResponseWithSideEffect>;
    fetchAndCache(req: Request, delegate: () => Promise<Response>): Promise<ResponseWithSideEffect>;
    /**
     * Handle fetching a request, using the configured strategy. `delegate` will invoke
     * the rest of the worker's fetch pipeline, ultimately fetching the request from the
     * network.
     */
    fetch(req: Request, delegate: () => Promise<Response>): Promise<ResponseWithSideEffect>;
    /**
     * Insert a new URL into the cache, returning a `Promise` that resolves when all
     * the metadata updates are complete.
     */
    private insertIntoCache(url, res);
    private updateIntoCache(url, res);
}
