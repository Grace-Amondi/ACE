import { ScopedCache, UrlMatcher } from '../../worker';
import { SortedLinkedList } from './linked';
var DEFAULT_CACHE_SIZE = 100;
/**
 * Optionally applies a side effect, returning a `Promise` which waits for the
 * side effect to be applied if it exists, or resolves immediately if not.
 */
export function maybeRun(sideEffect) {
    return !!sideEffect ? sideEffect() : Promise.resolve();
}
/**
 * Represents a specific cache group with a single policy.
 */
var DynamicGroup = (function () {
    /**
     * Consumers should use `DynamicGroup.open` instead.
     */
    function DynamicGroup(strategy, config, adapter, cache, matchers, metadata, clock) {
        var _this = this;
        // Obligatory Javaesque assignment of class properties.
        this.strategy = strategy;
        this.config = config;
        this.adapter = adapter;
        this.cache = cache;
        this.matchers = matchers;
        this.metadata = metadata;
        this.clock = clock;
        // Construct the queue with a comparison strategy based on the expiration
        // strategy chosen by the user.
        switch (config.cache.strategy) {
            case 'fifo':
                this.queue = new SortedLinkedList(this.fifoCompare.bind(this));
                break;
            case 'lfu':
                this.queue = new SortedLinkedList(this.lfuCompare.bind(this));
                break;
            case 'lru':
                this.queue = new SortedLinkedList(this.lruCompare.bind(this));
                break;
            default:
                throw new Error("Unknown cache strategy: " + config.cache.strategy);
        }
        Object.keys(this.metadata).forEach(function (url) { return _this.queue.insert(url); });
    }
    /**
     * Constructs a new `DynamicGroup`, based on the given manifest. If this group has
     * never existed before, it will be empty. If it has, the existing metadata will be
     * read out of
     */
    DynamicGroup.open = function (config, adapter, delegateCache, clock, strategies) {
        // The cache passed to open() isn't scoped, so construct a new one that's scoped.
        var cache = new ScopedCache(delegateCache, "dynamic:" + config.name + ":");
        // Select the desired strategy with which to process requests. If the user
        // asked for an invalid strategy, complain.
        var strategy = strategies[config.cache.optimizeFor];
        if (!strategy) {
            throw new Error("No registered optimizeFor handler (" + config.cache.optimizeFor + ") for group " + config.name);
        }
        // Construct the chain of `UrlMatcher`s for all of the URL matching configurations
        // provided in the manifest.
        var matchers = Object
            .keys(config.urls)
            .map(function (url) { return new UrlMatcher(url, config.urls[url], adapter.scope); });
        // Look through the metadata cache for all cached requests, load the metadata for
        // them, and add it to a metadata map, keyed by URL. If this is a fresh cache and
        // there are no requests, then cache.keysOf() will return an empty array, and the
        // resulting metadata map will be empty.
        return cache
            .keysOf('metadata')
            .then(function (keys) { return Promise.all(keys.map(function (key) { return cache
            .load('metadata', key)
            .then(function (resp) { return resp.json(); })
            .then(function (metadata) { return ({ url: key.url, metadata: metadata }); }); })); })
            .then(function (metadata) { return metadata.reduce(function (acc, curr) {
            acc[curr.url] = curr.metadata;
            return acc;
        }, {}); })
            .then(function (metadata) { return new DynamicGroup(strategy, config, adapter, cache, matchers, metadata, clock); });
    };
    /**
     * Match a `Request` against the URL patterns configured for this group.
     */
    DynamicGroup.prototype.matches = function (req) {
        return this.matchers.some(function (matcher) { return matcher.matches(req.url); });
    };
    /**
     * A comparison function for FIFO expiration, that compares two URLs by time added.
     */
    DynamicGroup.prototype.fifoCompare = function (urlA, urlB) {
        var a = this.metadata[urlA];
        var b = this.metadata[urlB];
        return compare(a.addedTs, b.addedTs);
    };
    /**
     * A comparison function for LFU expiration, that compares two URLs by access count.
     */
    DynamicGroup.prototype.lfuCompare = function (urlA, urlB) {
        var a = this.metadata[urlA];
        var b = this.metadata[urlB];
        return compare(a.accessCount, b.accessCount);
    };
    /**
     * A comparison function for LRU expiration, that compares two URLs by time accessed.
     */
    DynamicGroup.prototype.lruCompare = function (urlA, urlB) {
        var a = this.metadata[urlA];
        var b = this.metadata[urlB];
        return compare(a.accessedTs, b.accessedTs);
    };
    /**
     * Fetch a given request from the cache only.
     */
    DynamicGroup.prototype.fetchFromCache = function (req) {
        var _this = this;
        // Firstly, check for metadata. If it doesn't exist, there's no point in
        // continuing, the request isn't cached.
        var metadata = this.metadata[req.url];
        if (!metadata) {
            return Promise.resolve({ response: null });
        }
        // If the user's configured a maxAgeMs value for the cache, check the age of the
        // cached response against it. If it's too old, it needs to be removed from the
        // cache.
        var cacheAge = this.clock.dateNow() - metadata.addedTs;
        if (!!this.config.cache.maxAgeMs && cacheAge > this.config.cache.maxAgeMs) {
            // TODO: Possibly do this as a side effect and not inline.
            // Remove from the in-memory tracking.
            this.queue.remove(req.url);
            delete this.metadata[req.url];
            // And invalidate the entry in the actual cache.
            return Promise
                .all([
                this.cache.invalidate('cache', req.url),
                this.cache.invalidate('metadata', req.url),
            ])
                .then(function () { return ({ response: null }); });
        }
        // The cached response is valid and can be used.
        return this
            .cache
            .load('cache', req.url)
            .then(function (response) {
            // Something went wrong, abort.
            // TODO: maybe need to invalidate the metadata here?
            if (!response) {
                return { response: null };
            }
            // The response is ready, but the metadata needs to be updated. Since this is
            // outside the critical path for servicing the request, it is done in a side
            // effect.
            var sideEffect = function () {
                // Update the 'accessed' stats.
                metadata.accessCount++;
                metadata.accessedTs = _this.clock.dateNow();
                // Return a promise that saves the metadata to the metadata cache.
                return _this
                    .cache
                    .store('metadata', req.url, _this.adapter.newResponse(JSON.stringify(metadata)))
                    .then(function () {
                    _this.queue.remove(req.url);
                    _this.queue.insert(req.url);
                });
            };
            // Finally, construct the final `ResponseWithSideEffects`.
            return { response: response, cacheAge: cacheAge, sideEffect: sideEffect };
        });
    };
    // Fetch a request from the network and store the response in the cache.
    DynamicGroup.prototype.fetchAndCache = function (req, delegate) {
        var _this = this;
        // Call the delegate to run the rest of the fetch pipeline and get the response
        // from downstream plugins.
        return delegate()
            .then(function (response) {
            // Don't cache unsuccessful responses.
            if (!response.ok) {
                return { response: response };
            }
            // TODO: check response size to implement maxSizeBytes.
            // Need to clone the response, as the body will be read twice
            var toCache = response.clone();
            // Adding to the cache is implemented as a side effect.
            var sideEffect = function () {
                // Check if the request already has associated metadata. If it does, then
                // it needs to be updated, otherwise insert new metadata (possibly causing an
                // eviction).
                var metadata = _this.metadata[req.url];
                return !metadata
                    ? _this.insertIntoCache(req.url, toCache)
                    : _this.updateIntoCache(req.url, toCache);
            };
            // Return the response together with the side effect that will cache it.
            return { response: response, sideEffect: sideEffect };
        });
    };
    /**
     * Handle fetching a request, using the configured strategy. `delegate` will invoke
     * the rest of the worker's fetch pipeline, ultimately fetching the request from the
     * network.
     */
    DynamicGroup.prototype.fetch = function (req, delegate) {
        // If the request is mutating (not GET, OPTIONS, or HEAD) then it needs to go to the
        // server directly, bypassing the cache.
        if (req.method !== 'GET' && req.method !== 'OPTIONS' && req.method !== 'HEAD') {
            // TODO: invalidate cache on mutating request.
            var res = delegate().then(function (response) { return ({ response: response }); });
        }
        // Otherwise, delegate to the dynamic caching strategy to handle this request.
        return this.strategy.fetch(this, req, delegate);
    };
    /**
     * Insert a new URL into the cache, returning a `Promise` that resolves when all
     * the metadata updates are complete.
     */
    DynamicGroup.prototype.insertIntoCache = function (url, res) {
        var _this = this;
        // This should never happen, but sanity check that this entry does not have metadata
        // already.
        if (this.metadata[url]) {
            return Promise.reject(new Error("insertIntoCache(" + url + ") but url is already cached"));
        }
        // New metadata entry for this respones.
        var now = this.clock.dateNow();
        var metadata = {
            addedTs: now,
            accessCount: 1,
            accessedTs: now,
        };
        // Start a Promise chain to keep the code organized.
        return Promise
            .resolve()
            .then(function () {
            var maybeEvict = Promise.resolve();
            // Evict items until the cache has room for the new entry.
            var queueLength = _this.queue.length;
            while (queueLength >= (_this.config.cache.maxEntries || DEFAULT_CACHE_SIZE)) {
                queueLength--;
                maybeEvict = maybeEvict.then(function () {
                    // Need to evict something. Pick the top item on the queue and remove it.
                    var evictUrl = _this.queue.pop();
                    delete _this.metadata[evictUrl];
                    // Process the eviction, removing both the cached data and its metadata.
                    return Promise.all([
                        _this.cache.invalidate('cache', evictUrl),
                        _this.cache.invalidate('metadata', evictUrl),
                    ]);
                });
            }
            return maybeEvict;
        })
            .then(function () { return Promise.all([
            _this.cache.store('cache', url, res),
            _this.cache.store('metadata', url, _this.adapter.newResponse(JSON.stringify(metadata))),
        ]); })
            .then(function () {
            // After insertion is complete, track the changes in the in-memory metadata.
            _this.metadata[url] = metadata;
            _this.queue.insert(url);
        });
    };
    DynamicGroup.prototype.updateIntoCache = function (url, res) {
        var _this = this;
        var metadata = this.metadata[url];
        if (!metadata) {
            return Promise.reject(new Error("updateIntoCache(" + url + ") but url is not cached"));
        }
        // Update metadata.
        metadata.accessCount++;
        metadata.addedTs = metadata.accessedTs = this.clock.dateNow();
        return Promise
            .all([
            this.cache.store('cache', url, res),
            this.cache.store('metadata', url, this.adapter.newResponse(JSON.stringify(metadata))),
        ])
            .then(function () {
            _this.queue.remove(url);
            _this.queue.insert(url);
        });
    };
    return DynamicGroup;
}());
export { DynamicGroup };
/**
 * Compare two numbers, returning -1, 0, or 1 depending on order.
 */
function compare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a === b) {
        return 0;
    }
    else {
        return 1;
    }
}
//# sourceMappingURL=group.js.map