import { maybeRun } from '../group';
/**
 * A dynamic caching strategy which optimizes for the performance of requests
 * it serves, by placing the cache before the network.
 *
 * In the performance strategy, requests always hit the cache first. If cached
 * data is available it is returned immediately, and the network is not (usually)
 * consulted.
 *
 * An exception to this rule is if the user configures a `refreshAheadMs` age.
 * If cached responses are older than this configured age, a network request will
 * be made in the background to update them, even though the cached value is
 * returned to the consumer anyway. This allows caches to still be effective while
 * not letting them become too stale.
 *
 * If data is not available in the cache, it is fetched from the network and
 * cached.
 */
var PerformanceStrategy = (function () {
    function PerformanceStrategy() {
    }
    Object.defineProperty(PerformanceStrategy.prototype, "name", {
        /**
         * Name of the strategy (matched to the value in `optimizeFor`).
         */
        get: function () {
            return 'performance';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reads the cache configuration from the group's config.
     */
    PerformanceStrategy.prototype.config = function (group) {
        return group.config.cache;
    };
    /**
     * Makes a request using this strategy, falling back on the `delegate` if
     * the cache is not being used.
     */
    PerformanceStrategy.prototype.fetch = function (group, req, delegate) {
        // Firstly, read the configuration.
        var config = this.config(group);
        return group
            .fetchFromCache(req)
            .then(function (rse) {
            // Check whether the cache had data.
            if (rse.response === null) {
                // No response found, fall back on the network.
                return group.fetchAndCache(req, delegate);
            }
            else if (!!rse.cacheAge && config.refreshAheadMs !== undefined && rse.cacheAge >= config.refreshAheadMs) {
                // Response found, but it's old enough to trigger refresh ahead.
                // The side affect in rse.sideEffect is to update the metadata for the cache,
                // but that can be ignored since a fresh fetch will also update the metadata.
                // So return the cached response, but with a side effect that fetches from
                // the network and ignores the result, but runs that side effect instead
                // (which will update the cache to contain the new, fresh data).
                return {
                    response: rse.response,
                    cacheAge: rse.cacheAge,
                    sideEffect: function () { return group
                        .fetchAndCache(req, delegate)
                        .then(function (raRse) { return maybeRun(raRse.sideEffect); }); },
                };
            }
            else {
                // Response found, and refresh ahead behavior was not triggered. Just return
                // the response directly.
                return rse;
            }
        });
    };
    return PerformanceStrategy;
}());
export { PerformanceStrategy };
//# sourceMappingURL=performance.js.map