import { DynamicGroup, DynamicStrategy, ResponseWithSideEffect } from '../group';
import { CacheConfig } from '../manifest';
/**
 * Extension of the caching configuration specifically for freshness-optimized
 * caching.
 */
export interface FreshnessCacheConfig extends CacheConfig {
    optimizeFor: "freshness";
    /**
     * A timeout that if provided, will cause network requests to be abandoned
     * in favor of cached values if they take longer than the provided timeout.
     */
    networkTimeoutMs?: number;
}
/**
 * A dynamic caching strategy which optimizes for the freshness of data it
 * returns, by always attempting a server fetch first.
 *
 * In the freshness strategy, requests are always sent to the server first.
 * If the network request times out (according to the timeout value passed
 * in the configuration), cached values are used instead, if available.
 *
 * If the network request times out but the cache does not contain data,
 * the network value will still be returned eventually.
 *
 * Regardless of whether the request times out or not, if the network fetch
 * eventually completes then the result is cached for future use.
 */
export declare class FreshnessStrategy implements DynamicStrategy {
    /**
     * Name of the strategy (matched to the value in `optimizeFor`).
     */
    readonly name: string;
    /**
     * Reads the cache configuration from the group's config.
     */
    config(group: DynamicGroup): FreshnessCacheConfig;
    /**
     * Makes a request using this strategy, falling back on the `delegate` if
     * the cache is not being used.
     */
    fetch(group: DynamicGroup, req: Request, delegate: () => Promise<Response>): Promise<ResponseWithSideEffect>;
    /**
     * Constructs a promise that resolves after a delay.
     */
    private timeout(delay, clock);
}
