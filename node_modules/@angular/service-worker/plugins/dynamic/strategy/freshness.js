import { maybeRun } from '../group';
/**
 * A dynamic caching strategy which optimizes for the freshness of data it
 * returns, by always attempting a server fetch first.
 *
 * In the freshness strategy, requests are always sent to the server first.
 * If the network request times out (according to the timeout value passed
 * in the configuration), cached values are used instead, if available.
 *
 * If the network request times out but the cache does not contain data,
 * the network value will still be returned eventually.
 *
 * Regardless of whether the request times out or not, if the network fetch
 * eventually completes then the result is cached for future use.
 */
var FreshnessStrategy = (function () {
    function FreshnessStrategy() {
    }
    Object.defineProperty(FreshnessStrategy.prototype, "name", {
        /**
         * Name of the strategy (matched to the value in `optimizeFor`).
         */
        get: function () {
            return 'freshness';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reads the cache configuration from the group's config.
     */
    FreshnessStrategy.prototype.config = function (group) {
        return group.config.cache;
    };
    /**
     * Makes a request using this strategy, falling back on the `delegate` if
     * the cache is not being used.
     */
    FreshnessStrategy.prototype.fetch = function (group, req, delegate) {
        // Firstly, read the configuration.
        var config = this.config(group);
        var unrestrictedFetch = group
            .fetchAndCache(req, delegate)
            .catch(function () { return ({ response: null }); });
        // By default, wait for the network request indefinitely.
        var networkFetch = unrestrictedFetch;
        // If a timeout is defined, then only wait that long before reverting to
        // the cache.
        if (!!config.networkTimeoutMs) {
            // Race the indefinite fetch operation with a timer that returns a null
            // response after the configured network timeout.
            networkFetch = Promise.race([
                unrestrictedFetch,
                this
                    .timeout(config.networkTimeoutMs, group.clock)
                    .then(function () { return ({ response: null }); }),
            ]);
        }
        return networkFetch
            .then(function (rse) {
            if (rse.response === null) {
                // Network request failed or timed out. Check the cache to see if
                // this request is available there.
                return group
                    .fetchFromCache(req)
                    .then(function (cacheRse) {
                    // Regardless of whether the cache hit, the network request may
                    // still be going, so set up a side effect that runs the cache
                    // effect first and the network effect following. This ensures
                    // the network result will be cached if/when it comes back.
                    var sideEffect = function () { return maybeRun(cacheRse.sideEffect)
                        .then(function () { return unrestrictedFetch; })
                        .then(function (netRse) { return maybeRun(netRse.sideEffect); }); };
                    // Check whether the cache had the data or not.
                    if (cacheRse.response !== null) {
                        // Cache hit, the response is available in the cache.
                        return {
                            response: cacheRse.response,
                            cacheAge: cacheRse.cacheAge,
                            sideEffect: sideEffect,
                        };
                    }
                    else {
                        // The cache was missing the data. Right now, just fall back
                        // on the indefinite fetch from the network.
                        return unrestrictedFetch;
                    }
                });
            }
            else {
                // The network returned in time, no need to consult the cache.
                return rse;
            }
        });
    };
    /**
     * Constructs a promise that resolves after a delay.
     */
    FreshnessStrategy.prototype.timeout = function (delay, clock) {
        return new Promise(function (resolve) { return clock.setTimeout(resolve, delay); });
    };
    return FreshnessStrategy;
}());
export { FreshnessStrategy };
//# sourceMappingURL=freshness.js.map